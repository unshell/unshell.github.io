[{"title":"实用网站推荐","url":"/blog/2022/10/26/好用的网站推荐/","content":"\n> 以下推荐的网站，可能会不定时更新，具体实用情况见仁见智。\n\n## 科普类\n\n### 1.全历史\n\n[官方网站](https://www.allhistory.com/)\n\n呈现全世界文明的时间线，各个国家各个时代的重要事件、文物、画作、古籍的网站\n\n![AllHistory](/blog/image/suggest/allhistory.jpg)\n\n### 2.译学馆\n\n[官方网站](https://www.yxgapp.com/)\n\n国外知识类视频翻译网站，学习知识和常识\n\n![译学馆](/blog/image/suggest/yxgapp.jpg)\n\n### 3.词根词缀字典\n\n[官方网站](http://www.dicts.cn/)\n\n免费提供词根词缀搜索的网站\n\n![词根词缀字典](/blog/image/suggest/cigencizhui.jpg)\n\n## 播客类\n\n### 1.NPR\n\n[官方网站](https://www.npr.org/)\n\nNPR，即美国全国公共广播电台（National Public Radio），为大众提供了多种Podcasts。\n\n![译学馆](/blog/image/suggest/npr.jpg)\n\n## 数据类\n\n### 1.今日热榜\n\n[官方网站](https://tophub.today/)\n\n汇聚几乎所有主流平台的实时热榜\n\n![Tophub](/blog/image/suggest/tophub.jpg)\n\n## 工具类\n\n### 1.LaLaL.AI 声轨分离\n\n[官方网址](https://www.lalal.ai/)\n\n提取人声和乐器轨道的网站\n\n![LaLaL.AI](/blog/image/suggest/lalalai.jpg)\n\n### 2.ViruStotal 病毒检测\n\n[官方网站](https://www.virustotal.com/gui/)\n\n分析可疑文件和URL以检测恶意软件，只适用不明出处的文件**（切记不要将自己的个人信息上传）**\n\n![ViruStotal](/blog/image/suggest/virustotal.jpg)\n\n### 3.超级PDF\n\n[官方网站](https://xpdf.net/)\n\n免费**（普通用户每日3次免费机会）**，简单，强大的PDF工具\n\n![超级PDF](/blog/image/suggest/superpdf.jpg)\n\n### 4.Visual C++ 可再发行程序包\n\n[安装 Microsoft C 和 C++ (MSVC) 运行时库](https://learn.microsoft.com/zh-CN/cpp/windows/latest-supported-vc-redist)\n\n### 5.Visual C++ Redistributable Package\n\n[Visual C++ Redistributable for Visual Studio 2012 Update 4](https://www.microsoft.com/zh-CN/download/details.aspx?id=30679)\n\n## 素材类\n\n### 1.Slidesgo 免费PPT\n\n[官方网站](https://slidesgo.com/)\n\n无需注册的高质量免费PPT模板网站\n\n![Slidesgo](/blog/image/suggest/slidesgo.jpg)\n\n### 2.熊猫搜书\n\n[官方网站](https://ebook.huzerui.com/)\n\n聚合电子书网站的导航网站\n\n![熊猫搜书](/blog/image/suggest/ebook.jpg)\n\n### 3.Subscene\n\n[官方网站](https://subscene.com/)\n\n电影字幕资源网站\n\n![Subscene](/blog/image/suggest/subscene.jpg)\n\n## 娱乐类\n\n### 1.小霸王，其乐无穷\n\n[官方网站](https://www.yikm.net/)\n\n在网页上玩红白机等游戏，还支持联机对战\n\n![小霸王，其乐无穷](/blog/image/suggest/xbw.jpg)","tags":["推荐"]},{"title":"行业术语","url":"/blog/2022/04/14/行业术语/","content":"\n### ToB 和 ToC\n\nToB 指面向企业（Business），ToC 指面向普通用户（Customer）。即对于产品而言 ToC 产品和 ToB 产品 面向的使用群体不同。\n\n### OA 系统、CRM 系统、ERP 系统\n\nOA 系统（Office Automation）指办公自动化系统，用于实现多人、多部门、跨地域协同办办公模式。\n\nCRM 系统（Customer Relationship Management）自 1980 年代，CRM 开始萌芽，企业决策者开始关注销售自动化（SFA）、客户服务系统（CSS），结合起来就是今天 CRM 的前身，主要作用于帮助企业管理与客户间的业务关系。\n\nERP 系统（Enterprise Resource Planning）指企业资源计划，是一个将物流、财流、信息流集成化管理的应用系统，用于进行企业资源优化，是管理效益最大化。","tags":["术语"]},{"title":"Redis 哨兵模式","url":"/blog/2021/09/01/哨兵模式/","content":"\n## 前言\n\n**当前操作系统：Windows 10，Redis 版本：5.0.10 for Windows**\n\n> 哨兵模式简单来说是在主从模式下，添加哨兵进程以选举从节点替换宕机主节点的模式\n\n## 主从模式\n\n在了解哨兵模式前，得先将机器配置主从关系，以如下两台机器为例：\n\n- 192.168.67.130\n- 192.168.67.1\n\n接下来我打算将 192.168.67.130 配置为主节点（Master），而 192.168.67.1 从节点（Replica），一下我们以 M1 和 R1 分别代表两台机器\n\n```bash\n# 配置 M1 的 bind 为 192.168.67.130 以确保能被其他的客户端连接\nbind 192.168.67.130\n# 同样的，配置 R1 的 bind 为 192.168.67.1 以确保能被其他的客户端连接\nbind 192.168.67.1\n# 在 R1 的配置中设置 M1 为主从关系\nslaveof 192.168.67.130 6379\n# 当然也可以使用客户端连接 R1 后通过 SLAVEOF 指令配置主从关系\n192.168.67.1:6379> SLAVEOF 192.168.67.130 6379\nOK\n# 关联成功后 M1 和 R1 的 Redis 会将日志打印出来\n# M1 打印的日志如下：\n[7648] 01 Sep 17:04:39.883 * Starting BGSAVE for SYNC with target: disk\n[7648] 01 Sep 17:04:39.898 * Background saving started by pid 8684\n[7648] 01 Sep 17:04:40.040 # fork operation complete\n[7648] 01 Sep 17:04:40.040 * Background saving terminated with success\n[7648] 01 Sep 17:04:40.055 * Synchronization with replica 192.168.67.134:6379 succeeded\n# R1 打印的日志如下：\n[3468] 05 Sep 17:12:28.131 * Connecting to MASTER 192.168.67.130:6379\n[3468] 05 Sep 17:12:28.131 * MASTER <-> REPLICA sync started\n[3468] 05 Sep 17:12:28.131 * Non blocking connect for SYNC fired the event.\n[3468] 05 Sep 17:12:28.135 * Master replied to PING, replication can continue...\n[3468] 05 Sep 17:12:28.138 * Trying a partial resynchronization (request f3f4c3ebe082784cb0ad8b58703478619c2fe3bb:572504).\n[3468] 05 Sep 17:12:28.245 * Full resync from master: fd9a55223a42dcc57c8cbab087dcf66a4db20d52:0\n[3468] 05 Sep 17:12:28.245 * Discarding previously cached master state.\n[3468] 05 Sep 17:12:28.485 * MASTER <-> REPLICA sync: receiving 48086 bytes from master\n[3468] 05 Sep 17:12:28.487 * MASTER <-> REPLICA sync: Flushing old data\n[3468] 05 Sep 17:12:28.488 * MASTER <-> REPLICA sync: Loading DB in memory\n[3468] 05 Sep 17:12:28.496 * MASTER <-> REPLICA sync: Finished with success\n# 看到类似成功提示的日志，说明主备已经关联。\n# 如果你还不放心，你可以通关客户端分别连接到 M1 和 R1 并输入指令 info replication 来查看主备情况。\n# M1 显示如下：\nrole:master\nconnected_slaves:1\n# R1 显示如下：\nrole:slave\nmaster_host:192.168.67.130\nmaster_port:6379\nmaster_link_status:up\n# M1 的 connected_slaves:1 和 R1 的 master_link_status:up 足以说明主从关系已经建立成功\n```\n\n> 值得注意的是 Redis 5 之后的版本中有了一个新的指令 REPLICAOF 来迭代 SLAVEOF 指令，用于复制数据和建立主从关系。\n\n## 哨兵模式\n\n在官方提供的版本中默认有一个 sentinel.conf 配置文件，其中有基础的两个参数是需要注意的：\n\n```bash\n# port <sentinel-port>\n# The port that this sentinel instance will run on\n# 译：哨兵进程将通过此端口运行\nport 26379\n\n# sentinel monitor <master-name> <ip> <redis-port> <quorum>\n#\n# Tells Sentinel to monitor this master, and to consider it in O_DOWN\n# (Objectively Down) state only if at least <quorum> sentinels agree.\n# 译：通知 Sentinel 监视指定的 Master，并且只有在至少 <quorum> 哨兵同意时才考虑它处于 O_DOWN（客观关闭）状态。\n#\n# Note that whatever is the ODOWN quorum, a Sentinel will require to\n# be elected by the majority of the known Sentinels in order to\n# start a failover, so no failover can be performed in minority.\n#\n# Replicas are auto-discovered, so you don't need to specify replicas in\n# any way. Sentinel itself will rewrite this configuration file adding\n# the replicas using additional configuration options.\n# Also note that the configuration file is rewritten when a\n# replica is promoted to master.\n#\n# Note: master name should not include special characters or spaces.\n# <master-name> 为自定义项，但是不能包含特殊字符或空格。\n# The valid charset is A-z 0-9 and the three characters \".-_\".\nsentinel monitor mymaster 192.168.67.130 6379 1\n```\n\n> 1.哨兵进程端口一般以 Redis 端口前面加个 2 作为进程端口，当然得先确保 26379 为空闲端口。\n>\n> 2.只需要配置监听主节点的端口，从节点会被自动发现。\n\n根据上面的配置新建一个 sentinel.conf 文件并写入，然后通过 redis-server.exe 运行哨兵进程\n\n```bash\n# redis-server.exe <configure-path> --sentinel\nredis-server.exe sentinel.conf --sentinel\n# 运行后也会像运行 Redis 一样，打印出相关的内容以及日志：\n[8540] 06 Sep 09:20:02.646 # Sentinel ID is 6b2c189b490d72a61c73735e08702980635c13aa\n[8540] 06 Sep 09:20:02.646 # +monitor master mymaster 192.168.67.130 6379 quorum 1\n[8540] 06 Sep 09:20:02.648 * +slave slave 192.168.67.1:6379 192.168.67.1 6379 @ mymaster 192.168.67.130 6379\n```\n\n这里我们可以看到 Sentinel 给自己建了一个 ID，之后 +monitor 表示主节点被发现，随后 +slave 表示一个从节点被发现。\n\n## 其他\n\n- [Redis哨兵-实现Redis高可用](https://www.redis.com.cn/topics/sentinel.html)\n","tags":["Sentinel"]},{"title":"Windows 安装 Redis","url":"/blog/2021/09/01/Windows安装Redis/","content":"\n## 前言\n\n**当前操作系统：Windows 10，Redis 版本：5.0.10 for Windows**\n\n由于 Redis 官方并没有提供适用于 Windows 操作系统下运行的 Redis 程序，所以 Windows 操作系统下一般使用的是微软团队维护的开源 [Redis For Windows OS](https://github.com/tporadowski/redis/releases) 程序。\n\n## 设置配置\n\n解压下载的安装包，进入到解压后的目录。\n\n目录下有几个文件是需要注意的：\n\n- redis.windows.conf - 配置\n- redis-server.exe - 服务\n- redis-cli.exe - 客户端\n\n一般情况下流程为修改配置，运行服务，最后通过客户端连接。\n\n那我们先讲讲几个比较常用的配置（打开 redis.windows.conf 文件）：\n\n```ini\n# bind 配置接受处理的 IP 地址（注意这个 IP 是自己的内网或外网地址，而回环地址只能通过本机的客户端连接才有效）\nbind 127.0.0.1 或 bind 127.0.0.1 192.168.1.134\n# 配置 protected-mode 为开启（默认）时，访问将遵循 bind 和 requirepass 的规则\nprotected-mode yes\n# port 配置 Redis 服务占用的端口（默认为 6379）\nport 6379\n# requirepass 配置 客户端 连接密码（默认情况下被注释）\nrequirepass [你的密码]\n# 配置根据需求自行了解和设置，还有其他其他配置如 logfile 配置日志打印输出的文件地址、loglevel 配置日志监听的级别等配置这里就不多赘述了\n```\n\n## 运行服务\n\n设置完配置之后就可以尝试运行 Redis 服务\n\n```bash\n# 按配置运行服务（这里以全默认配置为例）\nredis-server.exe redis.windows.conf\n# 运行正常打印结果如下（logo 略）\n[1212] 01 Sep 09:14:16.489 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n[1212] 01 Sep 09:14:16.489 # Redis version=5.0.10, bits=64, commit=1c047b68, modified=0, pid=1212, just started\n[1212] 01 Sep 09:14:16.489 # Configuration loaded\n\nRedis 5.0.10 (1c047b68/0) 64 bit\n\nRunning in standalone mode\nPort: 6379\nPID: 1212\n\n           http://redis.io\n\n[1212] 01 Sep 09:14:16.493 # Server initialized\n[1212] 01 Sep 09:14:16.493 * Ready to accept connections\n```\n\n运行成功后可以尝试使用客户端连接\n\n```bash\n# h 表示主机、-p 表示端口、-a 表示密码、-n 表示特定编号的数据库\n# 当然主要的参数为 h 和 p，而密码和编号可以连接后通过 Auth [密码] 和 Select[编号] 命令指定\nredis-cli.exe -h 127.0.0.1 -p 6379 -a [密码] -n [数据库编号（0-15）]\n\n# 连接后会在光标前显示连接的主机和端口号\n127.0.0.1:6379>\n# 关闭 Redis（SHUTDOWN [SAVE|NOSAVE]）后显示 not connected\n127.0.0.1:6379> SHUTDOWN\nnot connected>\n# 关闭后 Redis 进程会打印出以下日志\n[1212] 01 Sep 10:55:33.562 # User requested shutdown...\n[1212] 01 Sep 10:55:33.562 * Saving the final RDB snapshot before exiting.\n[1212] 01 Sep 10:55:33.570 * DB saved on disk\n[1212] 01 Sep 10:55:33.570 # Redis is now ready to exit, bye bye...\n# 可以看出，客户端发出shutdown指令后，进行最后的RDB快照保存，DB存储到磁盘中，然后退出（可以看出 SHUTDOWN 默认为 SAVE）。\n```\n\n## Redis 安装到 Windows 服务\n\n```bash\n# 把 Redis 加入到 Windows 服务中\nredis-server.exe --service-install redis.windows.conf\n# 启动 Windows-Redis 服务\nredis-server.exe --service-start\n# 删除 Windows-Redis 服务\nredis-server.exe --service-uninstall\n# 当然 Windows 服务也可以通过 net 指令开启关闭\nnet start Redis 或 net stop Redis\n# 当然也可以通过 sc 命令删除 Windows 服务\nsc delete Redis\n```\n\n> 虽然本文内容很少，但是 Redis 的内容还是很多的，运行的指令和特殊的配置与模式（主从、哨兵、集群）都是日后可以探索的课题。\n","tags":["Redis"]},{"title":"账户权限基础","url":"/blog/2021/06/28/账户权限基础/","content":"\n## 运行环境\n\n系统：CentOS Linux release 7.9.2009 (Core)\n\n## 账户管理\n\n### 1.查看系统账户\n\n```shell\ncat /etc/passwd\n# 结果大致如下：\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\n......\n# 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n```\n\n### 2.添加系统账户\n\n**useradd [-mMnr] 用户名**\n\n- **参数说明**\n  - -m 　自动建立用户的登入目录\n  - -M 　不要自动建立用户的登入目录\n  - -n 　取消建立以用户名称为名的群组\n  - -r 　建立系统帐号\n\n> 当然这里只是部分的参数说明，因为还有大部分的参数在 usermod 中同样支持，更多参数可以 --help 查看。\n\n### 3.修改系统账户\n\n**usermod [-c <备注>][-d <登入目录>][-e <有效期限>][-f <缓冲天数>][-g <群组>][-G <群组>][-s <shell>][-u ] 用户账号**\n\n- **参数说明**\n  - -c<备注> 　修改用户帐号的备注文字\n  - -d登入目录> 　修改用户登入时的目录\n  - -e<有效期限> 　修改帐号的有效期限\n  - -f<缓冲天数> 　修改在密码过期后多少天即关闭该帐号\n  - -g<群组> 　修改用户所属的群组\n  - -G<群组> 　修改用户所属的附加群组\n  - -s<shell> 　修改用户登入后所使用的shell\n  - -u<uid> 　修改用户ID\n\n```shell\n# 修改用户的id（用户和群组都有唯一的id，修改群组时可以使用名称或id）\nusermod -u 777 root\n```\n\n### 4.删除系统账户\n\n**userdel [-r] 用户名**\n\n- **参数说明**\n  - -r\t用户的主目录一并删除\n\n### 5.用户口令管理\n\n**passwd [-ludf] 用户名**\n\n- **参数说明**\n  - -l 锁定口令，即禁用账号\n  - -u 口令解锁\n  - -d 使账号无口令\n  - -f 强迫用户下次登录时修改口令\n\n## 群组管理\n\n### 1.添加用户组\n\n**groupadd [-go] 用户组**\n\n- **参数说明**\n  - -g GID 指定新用户组的组标识号（GID）\n  - -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同\n\n### 2.修改用户组\n\n**groupadd [-gon] 用户组**\n\n- **参数说明**\n  - -n\t重命名用户组\n\n### 3.删除用户组\n\n**groupdel 用户组**\n\n> 如果一个账户通过 *-G* 设置了多个用户组，可以通过 *newgrp 用户组* 来切换其他用户组，已达到权限管理的目的。\n\n## 文件所属权\n\n当然我们设置用户以及用户组是为了分配权限，而分配权限的目的就是为了让不同的用户或者组只能操作属于自己权限内的文件或文件夹。\n\n### 设置文件所有者\n\n**chown [-cfhvR] user[:group] file...**\n\n- **参数说明**\n  - user : 新的文件拥有者的使用者 ID\n  - group : 新的文件拥有者的使用者组(group)\n  - -c : 显示更改的部分的信息\n  - -f : 忽略错误信息\n  - -h :修复符号链接\n  - -v : 显示详细的处理信息\n  - -R : 处理指定目录以及其子目录下的所有文件\n\n#### 示例\n\n```shell\n# 设置 /var/run/httpd.pid 文件的所有者为 root\nchown root /var/run/httpd.pid\n# 设置 /var/run/httpd.pid 文件的所属群组为 root\nchown :root /var/run/httpd.pid\n# 也可以一次性设置所有者和所属群组\nchown root:root /var/run/httpd.pid\n\n# 设置文件下所有文件的所有者为 root\nchown -R root /var/run\n# 或者使用编号也是同样的效果\nchown -R 0 /var/run\n```\n\n### 设置所有者操作权限\n\n**chmod [-cfvR] mode file...**\n\n- **参数说明**\n  - -c : 若该文件权限确实已经更改，才显示其更改动作\n  - -f : 若该文件权限无法被更改也不要显示错误讯息\n  - -v : 显示权限变更的详细资料\n  - -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)\n\n这里要注意的是 mode 的用法，首先我们得先了解一个文件包含三种权限：分别是读（r）、写（w）、执行（x），而给文件设置权限又包含三种操作：设置权限（=）、在原有权限的基础上添加权限（+）、在原有的基础上去除权限（-），所以很容易的可以得出 +w 为添加写权限、-x 为去除执行权限。\n\n然而仅仅有这两个符号还是不够的，文件权限还划分为三个等级，分别是：文件所有者（Owner）、用户组（Group）、其他用户（Users），三者的首字母代表符号模式。\n\n因为我们在之前给用户设置了用户组，所以要给文件的拥有组设置权限如：**chmod g+r httpd.pid**，当然也可以多个等级一起赋值如：**chmod ugo+r httpd.pid** 等同于 **chmod a+r httpd.pid**（a=all 代表所有权限等级）。\n\n```shell\n# 通过 ls 指令可以看出当前文件夹下所有文件的权限\nls -l\n# 大致为以下结构：\ndrwxr-xr-x.  19 root root  267 Jun 24 10:58 var\n# drwxr-xr-x，已等级划分分别为，rwx、-xr、r-x，-表示无权限，d表示文件类型（是文件夹则为d）\n# 当然我们可以看出var文件夹的所有者为root，所属用户组为root\n```\n\n有意思的是r、w、x可以用八进制来代替，分别是：r=4，w=2，x=1，所以：\n\n- 若要 rwx 属性则 4+2+1=7\n- 若要 rw- 属性则 4+2=6\n- 若要 r-x 属性则 4+1=5\n\n那么 **chmod a=rwx file** 与 **chmod 777 file** 效果相同。\n\n","tags":["Linux"]},{"title":"CentOs 更新 OpenSSH","url":"/blog/2021/06/24/CentOs更新OpenSSH/","content":"\n## 更新 OpenSSH\n\n> 更新前版本为OpenSSH_7.4pl，OpenSSL 1.0.2k-fips，更新目标版本为\n\n[OpenSSH基础介绍](https://www.cnblogs.com/lynk/p/10234115.html)\n\n### 1.下载最新版OpenSSH安装包\n\n```shell\n# pi 版为编译安装包\nwget https://openbsd.hk/pub/OpenBSD/OpenSSH/portable/openssh-8.6p1.tar.gz\n# 解压安装包\ntar -zxvf ./openssh-8.6p1.tar.gz\n```\n\n### 2.记录下当前sshd.pid的路径\n\n```shell\n# 从根目录开始查找 sshd.pid 文件\nfind / -name sshd.pid\n# 返回结果如下\n/run/sshd.pid\n```\n\n### 3.使用RPM指令删除老版本\n\n> rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用\n\n```shell\n# 查询 openssh 相关的所有套件（-a 查询所有，-q 询问模式）\nrpm -qa |grep openssh\n\n# 查询结果大致如下\nopenssh-clients-7.4p1-21.el7.x86_64\nopenssh-server-7.4.p1-21.el7.x86_64\nopenssh-7.4p1-21.el7.x86_64\n\n# 删除查询的结果（-e 删除指定的套件）\nrpm -e `rpm -qa |grep openssh`\n```\n\n### 4.安装依赖\n\n```sh\nyum install zlib-devel openssl-devel gcc gcc-c++ make -y\n```\n\n### 5.编译安装OpenSSH\n\n```shell\n# 设置 openssh-8.6p1 文件所有者及组为 root\nchown -R root:root ./openssh-8.6p1\n\n# 进入解压后的 OpenSSH 文件夹\ncd ./openssh-8.6p1\n\n# 获取 OpenSSL 的启动位置\nopenssl version -a\nOPENSSLDIR：\"/etc/pki/tls\"\n\n# 执行 configure 文件（--with-ssl-dir参数为上一步OpenSSL的位置）\n./configure --prefix=/usr/ --sysconfdir=/etc/ssh/ --with-ssl-dir=/etc/pki/tls --with-md5-passwords --with-kerberos5 --mandir=/usr/share/man/ \n# configure 成功后，会提示 OpenSSH has been configured with the following options：<!-- 配置信息 -->\n\n# 运行 make 和 make install 指令（&& 的意思是指 make 不出错则直接执行 make install）\nmake && make install\n```\n\n> 当软件通过源代码编译后安装，Configure 脚本工具是基础配置应用。\n\n以上 configure 用到的参数如下：\n\n- --prefix=PEWFIX：包在安装时可以彻底的重新安置他的结构独立部分\n- --sysconfdir=DIR：指定在单个机器上使用的只读数据的安装位置\n- --with-PACKAGE[=ARG]：当用'configure'来配置一个源码树时,可以提供其他已经安装的软件包的信息\n- --mandir=DIR：指定手册页的安装位置\n\n### 6.拷贝服务文件\n\n```shell\ncp ./contrib/redhat/sshd.init /etc/init.d/sshd\nchmod +x /etc/init.d/sshd\n```\n\n### 7.配置远程允许Root用户连接\n\n```shell\nvim /etc/ssh/sshd_config\n# 配置允许Root连接\nPermitRootLogin yes\n```\n\n### 8.启动SSH并添加到服务\n\n```shell\n# 启动 sshd\n/etc/init.d/sshd start\n# 设置sshd服务开启\nchkconfig sshd on\n# 查看 sshd 服务运行状态\nchkconfig --list sshd\n# 结果如下：\nsshd\t0:off\t1:off\t2:on\t3:on\t4:on\t5:on\t6:off\n```\n\n### 相关文章\n\n- [OpenSSH升级流程](https://blog.csdn.net/qq_33684555/article/details/81872110)\n- [Configure参数详解](https://www.cnblogs.com/tdalcn/archive/2011/11/11/2245402.html)\n- [centos 7 源码安装openssh 8.3](https://www.cnblogs.com/tianyingz/p/13048442.html)\n\n## Linux 安全策略\n\n### 1.设置密码失效时间\n\n```shell\nvim /etc/login.defs\n\n# 密码失效时间（9999为永不过期）\n# Maximum number of days a password may by used.\nPASS_MAX_DAYS\t90\n# 密码修改最小间隔天数（防止频繁修改）\n# Minimum number of days allowed between password changes.\nPASS_MIN_DAYS\t7\n# 密码最短长度\n# Minimum acceptable password length.\nPASS_MIN_LEN\t5\n# 密码过期前多少天开始提醒\n# Number of days warning given before a password expires.\nPASS_WARN_AGE\t7\n```\n\n一般设置安全策略 PASS_MAX_DAYS 为 90 天，设置后之前的账号并不会受到影响，新增的账户按照设置后的规则\n\n```shell\n# 如果需要对之前的用户也适用配置后的规则，如设置 root 账户的 PASS_MAX_DAYS 配置则执行如下命令\nchage --maxdays 90 root\n```\n\n### 2.密码复杂度检查\n\n```shell\nvim /etc/security/pwquality.conf\n\n# 密码最短长度\n# Minimum acceptable size for the new password.\nminlen = 10\n# 密码支持几种元素（如：数字，大写字母，小写字母，其他）\n# The minimum number of required classes of characters for the new password（digits，uppercase，lowercase，others）.\nminclass = 3\n```\n\n设置完成后，账户在设置密码或者修改密码时需要遵守这个规则\n\n### 3.密码重用限制\n\n```shell\nvim /etc/pam.d/password-auth\n# 在下面这一句的最后加上 remember=5，其他参数保持不变如下：\npassword    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok remember=5\nvim /etc/pam.d/system-auth\n# 在下面这一句的最后加上 remember=5，其他参数保持不变如下：\npassword    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok remember=5\n```\n\n设置完成后，账户修改密码时如果与该账户之前修改过的前五个密码相重则不允通过\n\n### 4.设置SSH空闲超时退出\n\n```shell\nvim /etc/ssh/sshd_config\n\n# 连接有效时长（如300到900，即5-15分钟）\nClientAliveInterval\t600\n# 连接最大数量限制\nClientAliveCountMax\t2\n```\n\n","tags":["OpenSSH"]},{"title":"编程术语","url":"/blog/2021/02/03/编程术语/","content":"\n### 语法糖（Syntactic sugar）\n\n由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指新增的语法对语言功能并没有影响但能更方便使用。\n\n### 对象关系映射（Object Relational Mapping）\n\n对象数据库管理系统，发端于1970年代早中期为支持对图结构对象的原生数据库管理而开展的研究，用于实现**面向对象编程**语言里不同**类型系统**的数据之间的转换。\n\n| 编程语言 | ORM框架                  |\n| -------- | ------------------------ |\n| C#       | ADO.NET Entity Framework |\n| Java     | Hibernate、Mybatis       |\n| NodeJs   | TypeORM                  |\n\n### 中间件\n\n中间件（Middleware）这个术语第一次出现是 1968 年在德国加尔米施帕滕基兴举办的 [NATO 软件工程大会] 结束后发表的一份报告中，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的`软件`。","tags":["术语"]},{"title":"Layui源码解读","url":"/blog/2021/01/11/Layui源码解读/","content":"\n### 经典开场\n```javascript\n// Layui\n;! function (win) {\n    var Lay = function () {\n        this.v = '2.5.5';\n    };\n    win.layui = new Lay();\n}(window);\n// Jquery\n(function (global, factory) {\n    \"use strict\";\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        module.exports = global.document ?\n            factory(global, true) :\n            function (w) {\n                if (!w.document) {\n                    throw new Error(\"jQuery requires a window with a document\");\n                }\n                return factory(w);\n            };\n    } else {\n        factory(global);\n    }\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n    var jQuery = function (selector, context) {\n        return new jQuery.fn.init(selector, context);\n    };\n    return jQuery;\n});\n```\n这是一种很经典的开场方式，以 **!** 定义一个函数并立即执行，并且将对象赋值到全局 **window** 变量上。当然除了 **!** 还有 **~** 等符号都可以定义后面的这个函数，而 **;** 应该是为了防止其他的代码对本身造成影响。\n\n实际上`( function (window) { \"use strict\"; } )( window )`的写法更被我们理解，如Jquery未压缩的源码。而**!**定义函数的方法唯一优势就是代码相对较少，所以压缩后的Js代码大多数会以 **!** 开头。\n\n### 动态加载\n```javascript\nLay.prototype.link = function (href, fn, cssname) {\n    var that = this,\n        link = doc.createElement('link'),\n        head = doc.getElementsByTagName('head')[0];\n    if (typeof fn === 'string')\n        cssname = fn;\n    var app = (cssname || href).replace(/\\.|\\//g, '');\n    var id = link.id = 'layuicss-' + app,\n        timeout = 0;\n    link.rel = 'stylesheet';\n    link.href = href + (config.debug ? '?v=' + new Date().getTime() : '');\n    link.media = 'all';\n    if (!doc.getElementById(id)) {\n        head.appendChild(link);\n    }\n    if (typeof fn != 'function') return that;\n    (function poll() {\n        if (++timeout > config.timeout * 1000 / 100) {\n            return error(href + ' timeout');\n        };\n        if (parseInt(that.getStyle(doc.getElementById(id), 'width')) === 1989) {\n            fn();\n        } else {\n            setTimeout(poll, 100);\n        }\n    }());\n    return that;\n}\n```\n先来看看官方文档：\n\n> **方法：layui.link(href)**\n> href 即为 css 路径。注意：该方法并非是你使用 layui 所必须的，它一般只是用于动态加载你的外部 CSS 文件。\n\n虽然官方只给出了一个参数，但是我们看源码的话可以知道后两个参数是加载完后运行的函数和自定义的Id。\n有趣的是，临时创建的 **poll函数** 如果`parseInt(that.getStyle(doc.getElementById(id), 'width')) === 1989`判断为 **false** ，也就是样式没有被引入的时候会重新调用 **poll函数** 最后要么加载成功循环结束，要么加载超时调用 **Layui hint** 打印出超时信息。\n因为同样的手段在加载 **module** 时也同样使用到，所以如果你使用过 Layui 那么`[module] is not a valid module`这样的警告或多或少能遇到几次。\n\n### 模块引入\n用过 Layui 的兄dei应该对 **layui.use** 不陌生，先来看官方文档：\n> **方法：layui.use([mods], callback)**\n> layui 的内置模块并非默认就加载的，他必须在你执行该方法后才会加载。\n\n对于用了 Layui 有段时间的我来说，也只是按照官方的例子使用，并不知道实现的原理。\n接下来就是见证遗迹的时候，看看 **layui.use** 做了什么：\n\n```javascript\nLay.fn.use = function (apps, callback, exports) {\n    function onScriptLoad(e, url) {\n        var readyRegExp = navigator.platform === 'PLaySTATION 3' ? /^complete$/ : /^(complete|loaded)$/;\n        if (e.type === 'load' || (readyRegExp.test((e.currentTarget || e.srcElement).readyState))) {\n            config.modules[item] = url;\n            head.removeChild(node);\n            (function poll() {\n                if (++timeout > config.timeout * 1000 / 4) {\n                    return error(item + ' is not a valid module');\n                };\n                config.status[item] ? onCallback() : setTimeout(poll, 4);\n            }());\n        }\n    }\n    function onCallback() {\n        exports.push(layui[item]);\n        apps.length > 1 ? that.use(apps.slice(1), callback, exports) : (typeof callback === 'function' && callback.apply(layui, exports));\n    }\n    var that = this,\n        dir = config.dir = config.dir ? config.dir : getPath;\n    var head = doc.getElementsByTagName('head')[0];\n    apps = typeof apps === 'string' ? [apps] : apps;\n    if (window.jQuery && jQuery.fn.on) {\n        that.each(apps, function (index, item) {\n            if (item === 'jquery') {\n                apps.splice(index, 1);\n            }\n        });\n        layui.jquery = layui.$ = jQuery;\n    }\n    var item = apps[0],\n        timeout = 0;\n    exports = exports || [];\n    config.host = config.host || (dir.match(/\\/\\/([\\s\\S]+?)\\//) || ['//' + location.host + '/'])[0];\n    if (apps.length === 0 || (layui['layui.all'] && modules[item]) || (!layui['layui.all'] && layui['layui.mobile'] && modules[item])) {\n        return onCallback(), that;\n    }\n    if (config.modules[item]) {\n        (function poll() {\n            if (++timeout > config.timeout * 1000 / 4) {\n                return error(item + ' is not a valid module');\n            };\n            if (typeof config.modules[item] === 'string' && config.status[item]) {\n                onCallback();\n            } else {\n                setTimeout(poll, 4);\n            }\n        }());\n    } else {\n        var node = doc.createElement('script'),\n            url = (modules[item] ? dir + 'lay/' : /^\\{\\/\\}/.test(that.modules[item]) ? '' : config.base || '') + (that.modules[item] || item) + '.js';\n        node.async = true;\n        node.charset = 'utf-8';\n        node.src = url + function () {\n            var version = config.version === true ? config.v || (new Date()).getTime() : config.version || '';\n            return version ? '?v=' + version : '';\n        }();\n        head.appendChild(node);\n        if (!node.attachEvent || (node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code]') < 0) || isOpera) {\n            node.addEventListener('load', function () {\n                onScriptLoad(e, url);\n            }, false);\n        } else {\n            node.addEventListener('onreadystatechange', function (e) {\n                onScriptLoad(e, url);\n            });\n        }\n        config.modules[item] = url;\n    }\n    return that;\n};\n```\n\n首先跳过前两个创建的函数，经过一堆巴拉巴拉的赋值后来到第2个if中我们直接可以判断语句`apps.length === 0`，根据文档可知我们第一个参数是一个数组 **[mods]** ，当然前面的赋值`apps = typeof apps === 'string' ? [apps] : apps;`可以看出即使你传的是一个字符串也会被封装成数组。 \n\n很明显第一次进来`apps.length === 0`和下面的`if ( config.modules[item] )` 也必为 false ，那么我们直接移步到 else 内。\n\n创建一个 script 元素并赋予属性和模块的地址，通过 appendChild 追加到 head 之后留下一个 addEventListener 监听 script 的加载（ ps：attachEvent 是给非人类使用的浏览器准备的 ）并将开始创建的` function onScriptLoad(e, url)`函数抛进去，然后整段代码除了`return that`到这里戛然而止。\n\n再来看看` function onScriptLoad(e, url) `函数，首先开幕雷击` \"PLaySTATION 3\" === navigator.platform` ？\n\n![Layui 的业务已经发展到PS3上了吗？](https://upload-images.jianshu.io/upload_images/13907412-625b822bf78d91c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n仅关心PC端浏览器的部分` e.type === 'load' `， 因为监听的是 **load** 所以这里必为 **true** 并执行`config.modules[item] = url`后将追加的 script 元素移除。剩余的代码就是动态加载时使用的技巧，直到` config.status[item]` 为 **true** 时循环结束。\n\n### 定义模块\n\n由于` config.status[item] `不会自动变成 **true**，之后的骚操作由 **layui.define** 接手。\n\n先看官方文档：\n\n> **方法：layui.define([mods], callback)**\n>\n> 通过该方法可定义一个 *layui 模块*。参数 mods 是可选的，用于声明该模块所依赖的模块。callback 即为模块加载完毕的回调函数，它返回一个 exports 参数，用于输出该模块的接口。\n\n以比较常用的 **laypage.js** 模块为例，基础源码如下：\n\n```javascript\n// Laypage 模块的部分代码（部分变量名为猜测，但不影响内容本身）\nlayui.define(function (exports) {\n    'use strict';\n    var MOD_NAME = 'laypage',\n        LayPage = function (options) {\n            var that = this;\n            that.config = options || {}, that.config.index = ++laypage.index, that.render(true);\n        };\n    var laypage = {\n        render: function (options) {\n            var laypage = new LayPage(options);\n            return laypage.index\n        },\n        index: layui.laypage ? layui.laypage.index + 10000 : 0,\n        on: function (elem, even, fn) {\n            return elem.attachEvent ? elem.attachEvent(\"on\" + even, function (param) {\n                param.target = param.srcElement, fn.call(elem, param)\n            }) : elem.addEventListener(even, fn, false), this\n        }\n    };\n    exports(MOD_NAME, laypage);\n});\n```\n\n因为 Layui 已经注册了全局的变量，所以当模块文件通过元素追加的方式引入时，调用了 **layui.define** 方法：\n\n```javascript\nLay.fn.define = function (deps, callback) {\n    var that = this,\n        type = typeof deps === 'function',\n        mods = function () {\n            var e = function (app, exports) {\n                layui[app] = exports;\n                config.status[app] = true;\n            }\n            typeof callback === 'function' && callback(function (app, exports) {\n                e(app, exports);\n                config.callback[app] = function () {\n                    callback(e);\n                }\n            });\n            return this;\n        };\n    type && (callback = deps, deps = []);\n    if (!layui['layui.all'] && layui['layui.mobile']) {\n        return mods.call(that);\n    } else {\n        that.use(deps, mods);\n        return that;\n    }\n};\n```\n\n因为不管你在定义的模块中有没有引入其他模块，如 laypage 和 laytpl 这些 Layui 本身提供的模块都会因 `(callback = deps, deps = [])` 回到 [mods], callback 的参数格式。\n\n再经过一系列巴拉巴拉的步骤回到定义的 mods 方法中，由`layui[app] = exports, config.status[app] = true`给全局 layui 变量添加属性(app)且给属性赋值(exports)，并把 status 改为 true 至此模块加载完成。\n\n### 总结\n\n正如 Layui 官方所说：*我们认为，这恰是符合当下国内绝大多数程序员从旧时代过渡到未来新标准的最佳指引*。\n\n作为一个后端的工作者（以后可能要接触前端框架的人）没有接触过前端框架，只对原生态的 HTML / CSS / JavaScript 有所了解，那么 Layui 无非是较优的选择。\n\n而写这篇文章无非就是为了感谢 Layui 对非前端工作者做出的贡献，也可能是我对使用了两年多 Layui 最后的告别吧，感谢贤心。\n\n### 相关网站\n\n- [Layui - 经典模块化前端 UI 框架](https://www.layui.com/)\n- [UglifyJS - JS压缩器](http://lisperator.net/uglifyjs/)","tags":["源码"]},{"title":"语宙法则","url":"/blog/2020/10/29/语法语法语法/","content":"\n## 词类\n\n虽然句子才是关键，但是句子是由单词构成的，所以了解不同单词的词性也就变的极为重要\n\n### 实词 Content Words\n\n- 能够单独充当句子成分\n- 有实在的词汇意义和语法意义\n\n| 实词   | 英文名称  |例子|英文|\n|-|-|-|-|\n|名词|Noun|大象|elephant|\n|代词|Pronoun|你|you|\n|动词|Verb|学习|study|\n|形容词|Adjective|好玩的|interesting|\n|副词|Adverb|高效的|efficiently|\n|数词|Numeral|七|seven|\n\n### 虚词 Function Words\n\n- 不能够单独充当句子成分\n- 没有完整的词汇意义\n- 有语法意义\n\n|词类|英文名称|例子|\n|-|-|-|\n|冠词|Article|a/an 一个，the 这个|\n|介词|Preposition| on 在....上面|\n|连词|Conjunction|if 如果|\n|助动词|Auxiliary|can 可能|\n|感叹词|Interjection|ah 啊|\n\n### 非谓语动词\n\n动名词、分词和不定式被称为非谓语动词，在句子中可以充当名词、形容词和副词来使用，但唯独不能充当动词使用。\n\n> 非谓语动词更像是**从句**的结构\n\n## 句子成分\n\n简单来说词充当句子中的成分，理解成分就能剖析句子。\n\n### 主干成分\n\n主谓宾补是句子的主干成分，所以我们很快得出了以下三个句型：\n\n|代号|句型|\n|-|-|\n|S + V|主语 + 谓语|\n|S + V + O|主语 + 谓语 + 宾语|\n|S + V + C|主语 + 谓语 + 补语/表语|\n\n然而有时候即使存在宾语和补语也不一定能把话说清楚，所以还有以下两种句型：\n\n|代号|句型|\n|-|-|\n|S + V + O + O|主语 + 谓语 + 宾语 + 宾语|\n|S + V + O + C|主语 + 谓语 + 宾语 + 补语|","tags":["笔记"]},{"title":"视频的相关知识","url":"/blog/2020/10/21/视频的相关知识/","content":"\n## 概要\n\n国内使用25帧或倍数帧率，并使用MP4格式封装，码率低于视频传播平台的限定码率上传以保持良好的画质。\n\n本章完🙄\n\n## 位深 - Color Depth\n\n所谓的8Bit位深是红、绿、蓝`RGB`三个通道色彩各有256个灰度`2的8次方`。当把3个通道能呈现的色彩相乘`256的3次方`所能得到的就是8Bit能呈现的色彩`16777216色`。\n\n> 色彩断层就是有位深不够导致的，当然可以增加位深来解决，如10Bit位深。\n\n## 色度采样 - Chroma Sampling\n\n先明白一个概念，就是一个像素块有两个信息，明度值和色度值。\n\n如果去掉色度值将会获得一个黑白的画面，但是如果去掉明度值就会一片黑。\n\n所以说只要保留明度信息画面内容依然存在，而多个像素共享一个色度值可以大大减少数据量。\n\n如果要实现这个，我们就无法使用RGB模式来呈现画面。而可以分离画面的明度`Y`，然后分离出两个色度通道`Cr和Cb`，当这些都结合起来时就呈现了YCrCb模式，也就是色彩采样中最常见的色彩模式。\n\n## 封装格式 - Format\n\n首先MOV和MP4就是我们常见的封装格式，当一个视频的后缀是.mp4是说明视频由MP4格式封装。\n\n那如果把封装格式比作一个箱子的话，里面装进了视频帧、音频、媒体信息、字幕文件，等到播放的时候软件会打开这个箱子，用正确的方式使用里面的内容。\n\n> 对于互联网传播通畅应该使用MP4来进行封装\n\n## 编码 - Codec\n\n- 编码器 - Coder\n- 解码器 - Decoder\n\n一个完全无压缩的8Bit RGB、4K视频的码率会是5Gbits，相当于每秒622MB/s的数据，录制几十分钟就会超过2TB，这绝对不是我们电脑或网络能够承受的数据量，所以编码就诞生了。\n\n而编码总归为三种类型，拍摄编码、剪辑编码、输出编码，而这三个过程中，素材的编码应对工作需求发生改变。\n\n最常听到的编码有H.264或PRORES，它们的区别就是H.264为帧间编码`InterFrame`而PRORES为帧内编码`IntraFrame`。\n\n### 帧内编码 - Intraframe\n\n针对每一帧的画面单独分析，优点是电脑回放的时候回比较轻松，缺点是压缩空间有限。\n\n### 帧间编码 - Interframe\n\n先记录两张完美的画面，然后只记录中间像素产生的变化，那么在后期解码的时候重新运算出中间的帧就可以恢复当时的画面。优点是压缩空间变大，而缺点也很明显，只要计算机算力不行那就需要无法流畅的回放画面。\n\n> 计算机性能不行的话可以生成代理文件处理帧间编码的素材，原理就是把帧间编码转换为像素更低的帧内编码减少计算机在性能方面的需求，当然剪辑完成后得替换成原素材导出。\n\n## 码率 - Bitrate\n\n- 恒定码率 - CBR\n- 可变码率 - VBR\n\n恒定码率就不多说了，可变码率也很容易理解，面对复杂的画面编码器会提供更多的码率，而简单的画面则减少码率，这样做的优点就是，即使在文件大小不变的情况下，视频整体质量也会得到很大的提升。\n\n值得注意的是在大多数情况下，视频平台在上传视频后可能对视频进行压缩，导致的结果就是降低视频码率。\n\n然而编码器难以预测像素的运动，所以当码率低，而画面随机运动的粒子多的时候，画面就会崩溃。\n\n所以保持一个健康的码率，对于视频的质量来说尤为重要。\n\n而面对压缩当然也有方法解决：\n\n1. 视频码率限定在平台限定码率之下。\n2. 选择高质量的码率接受二次压缩，但是在拍摄画面时减少复杂画面的出现。\n\n## 帧率 - FPS\n\n如果你做过视频，那么你应该多24、25、23.976、29.97、30、60很面熟，那么想要了解这些，我们得先了解一个词就是**视觉暂留**。\n\n> 简单来说就是人眼在短时间看到一系列微小差异的画面时，每个画面会在视网膜上短暂停留，通过人脑处理后得出一个运动的画面。\n\n那么画面在多快的速度下出现，才能使人看到流畅的运动画面呢？\n\n当时爱迪生提出人眼所能感知的最舒适的帧率不应该低于46帧，如果低于46帧人眼会感到不适。而在过去，胶片是很贵的，如果以46帧来拍摄画面那得是一笔不小的支出。\n\n而降低帧率播放会导致电影放映时出现黑帧闪烁，当然解决方法就是利用双叶片或是三叶片的快门进行放映，那么采用快门的放映会对同一帧的画面进行多次闪烁，想当于多次放映从而提高投影的实际帧速率。\n\n所以当时的无声电影采用16 - 18帧每秒进行记录，通过三叶片放映快门放映时就能够得到一个48 - 54帧的影片。\n\n然而到了电影中声音的加入后，帧率由以前的参差不齐归为统一。因为一旦播放帧率发生变化声音就会失真，所以这就是24帧的由来。\n\n> 因为24帧足以保留声音的细节，而且能被2、3、4、6、8整除以及考虑到胶片时代胶片很贵等因素。\n\n*当然以上说的都是电影，而电视机的出现，电子帧率应运而生*\n\n由于电视机的荧光屏不能像电影放映机一样，而是以主动发光的形式导致闪烁带来的不适应感更加明显。\n\n所以屏幕上的呈现形式出现了，就是逐行扫描`P`和隔行扫描`I`。比如1080i 60就是隔行扫描每秒60帧的半帧，而1080p 30代表逐行扫描每秒30帧的全帧，前者通过牺牲画面细节保持画面流畅和不闪眼，而后者虽然细节更丰富但画面流畅度降低且闪烁频率低导致非常累眼睛。\n\n> 如果是互联网传播则老老实实用逐行扫描`P`，现在熟知的 1080p 就是这个意思。\n\n而为了消除电流和电视信号在不同频率下相互干扰产生的噪点和杂音，就把隔行扫描的刷新率设置为交流电源赫兹频率一致。如国内就是50HZ对应隔行扫描`I`的每秒50帧半帧以及逐行扫描`P`的每秒25帧全帧。美国交流电源赫兹为60HZ，这也是30帧的由来。\n\n*而彩色电视出现是，帧率又出现了新的变化*\n\n色彩信息的加入使得原本黑白电视的信息宽带中加入了色彩信号，这样拥有黑白电视的人可以继续看黑白电视，而土豪们则能够读取色彩信息。\n\n但是色彩信号使用的频段极有可能和声音信号产生干扰产生噪音和画面扭曲，于是解决办法就是把画面的帧率做0.1%比例的缩减来避免两者之间交互产生干扰，于是 23.976 和 29.97 诞生。\n\n## 更好康的内容\n\n- [422，420，10bit，8bit？这些究竟是什么](https://www.bilibili.com/video/BV1ds411T7F4?t=269)\n- [高画质的背后——视频的封装与编码](https://www.bilibili.com/video/BV1ws41157f8?t=356)\n- [【硬核科普】奇妙的帧率增加了！](https://www.bilibili.com/video/BV1kE411c7yZ?t=585)\n\n> 本文所有内容为以上视频内容的总结记录","tags":["杂记"]},{"title":"阅读笔记 | 太宰治","url":"/blog/2020/10/12/太宰治的故事/","content":"\n![太宰治](/blog/image/taizaizhi/self.jpg)\n<center>图为太宰治，一看就知道是老网抑云患者了</center>\n\n## 时代背景\n\n出生于帝国时代（明治年间，后经过大正、昭和时代），可以说是经历过第一次世界大战的发生和第二次世界大战结束的男人，在二战过后的几年因病去世。\n\n## 个人经历\n\n- 1909年6月19日出生于**青森县**（日本本州最北部的一个县）的一个地主家庭，家族中子女共11人，他是第10个小孩。\n- 1916年（7岁）就读于本市的金木普通小学，成绩杰出。\n- 1921年（12岁）以第一名的成绩远至明治高等小学就读。\n- 1923年（14岁）3月，**父亲（津岛源右卫门）**去世，享年53岁。4月至县内的青森中学就读并寄宿于远亲丰田家中，中学期间开始创作。\n- 1925年（16岁）发布《最后的太阁》，并与友人合编同人志《星座》。\n- 1927年（18岁）就读于弘前高等学校文科甲组（英语），寄宿于远亲藤田豊三郎家中。期间喜爱**泉镜花**及**芥川龙之介**的作品，年间芥川龙之介自杀，甚受冲击，并在同年秋天与青森艺妓**小山初代**相识。\n- 1929年（20岁）受当时流行的无产阶级文学影响，在同人志《细胞文艺》创办时以`辻岛众二`之名发表作品，受到**井伏鳟二**指导，这时候也有用`小菅银吉`或是本名来写文章。12月因烦恼本身的阶级问题而企图以安眠药自杀未遂。\n- 1930年（21岁）仅因为憧憬法国文学，而在不懂法语的情况下就读于东京帝国大学发文系，住宿在户冢取访町常盘馆，并奉**井伏鳟二**为师。参与非法的左翼运动而怠惰学业，以致最后被开除学籍。在学期间接触，烟酒，酒家女，经常透支家里寄来的生活费。与银座咖啡店侍女`有夫之妇`**部目津子**相识，并同居。于11月相约**部目津子**殉情，本人获救，但目津子死亡。此事是他终身难忘的罪恶意识，心境凝结在《小丑之花》一文中。\n\n![部目津子](/blog/image/taizaizhi/mujinzi.jpg)\n<center>图为殉情者：部目津子</center>\n\n- 1931年（22岁）与小山初代同居。\n- 1932年（23岁）因对左翼非法运动绝望，向青森警察局自首。专心于写作之中。\n- 1933年（24岁）在《Sunday东奥》上发表短篇作品《列车》。参加同人志《海豹》发表《鱼服记》。\n- 1935年（26岁）在《文艺》发表《逆行》，成为第一届**芥川赏**的候补作品。3月因求职于东京都新闻社失败，企图上吊自杀。同年拜**佐藤春夫**为师，期间患盲肠炎并发腹膜炎和药物中毒。\n- 1936年（27年）在**井伏鳟二**的劝导下，进入武藏野医院专注于治疗前一年的药物中毒。发行作品集处女作《晚年》，共收入40篇短篇小说。期待已久的第三回芥川奖落选，备受打击。\n- 1937年（28岁）和初恋对象小山初代以服安眠药自杀未遂。并回东京后于初代离别。\n- 1938年（29岁）停笔一年后，以《姨舍》复活，由恩师**井伏鳟二**作媒，和教师**石原美知子**结婚。之后，精神上较安定，写了《富岳百景》等作品。\n- 1939年（30岁）发表《女学生》，获第四届北村透谷文学奖。此外尚有《御伽草纸》，发挥了作家奔放的想象力。\n- 1942年（33岁）母亲去世。\n- 1943年（34岁）与妻子结伴返乡。\n- 1944年（35岁）受**大东亚会议**委托将《大东亚五大宣言》小说化，开始研究鲁迅，去往仙台调查鲁迅的事迹。同年**小山初代**于青岛去世。\n- 1945年（36岁）9月出版以**鲁迅**为模特的小说《惜别》，获得好评不多。为了生活以`黑木舜平`为笔名写了心理悬疑小说《断崖的错觉》，但太宰本身以此作品为耻。\n- 1948年（39岁）再次以《如是我闻》震惊文坛，并着手创作《人间失格》`No Longer Human`。在完成《第二手记》的部分时，肺结核的恶化，身体极度虚弱时长吐血。6月13日和山崎富荣一起投井自尽，39岁生日当天才被发现。死后葬于**三鹰町禅林寺**。\n\n![山崎富荣](/blog/image/taizaizhi/shanqifurong.jpg)\n<center>图为山崎富荣</center>\n\n## 特殊成就\n\n- 自杀狂魔（4次自杀未遂）\n\n- 美女终结者\n\n## 其他时期的照片\n\n![太宰治](/blog/image/taizaizhi/self01.jpg)\n<center>中学时期的太宰治</center>","tags":["人物介绍"]},{"title":"对于感冒的一些记录","url":"/blog/2020/10/09/对于感冒的一些记录/","content":"\n就在国庆和中秋连放长假期间我感冒了，😞哎∽（还好没有发烧），所以写点相关的内容记录一下。\n\n## 怎么就感冒了？\n\n### 1.着凉了\n\n当然着凉的原因有很多种，比如：晚上踢被子，淋到雨了。\n\n种种原因让你的体温降低了，而`rhinovirus`人鼻病毒正好在低温下更容易繁殖，于是你被转了空子。\n\n### 2.被传染了\n\n假如你和流感病毒患者聊天时，他正好打了个喷嚏，飞沫又刚好被你吸入鼻子，而恰好病毒从你的鼻腔偷摸的溜到你的咽喉部位，这个时候一场大战即将开始打响了。\n\n> 当然两种类型是不同的，症状也略有不同。\n\n## 鼻子堵了好难受\n\n鼻子堵了是感冒最难受的现象之一，不对...，是唯一😤。\n\n鼻涕水已经流成这样了，竟然还把我鼻子给堵掉，这不是雪上加霜嘛！\n\n我们可以先看下鼻腔的结构，如下图：\n\n![鼻腔状切面解刨图](/blog/image/virus/nasal.jpg)\n可以看到鼻腔的中间有三条杠是鼻甲，而中间的空隙就是允许气流通过的部分（事实上空间原本就不是很大）。\n\n> 当鼻腔内的粘膜发炎，充血产生肿胀（让空气流通的通道更加拥挤）以及渗出，就出现了鼻塞和流鼻涕的现象。\n\n## 感冒药不治感冒\n\n当听到感冒药不治感冒时其实我是不能接受的。\n\n但实际上感冒能治愈都是因为我们自己本身的免疫系统，而感冒药只是用来控制感冒症状（鼻塞，头疼，发热）的。\n\n## 治疗感冒的主力：免疫系统\n\n其实从刚开始病毒进入时，免疫系统就开始起作用了。\n\n1. 鼻腔的绒毛就是第一道防线，捕获吸进的所有异物，通过打喷嚏和流鼻涕把异物排除。\n2. 当然总有漏网之鱼，它们突破了第一道防线进入了咽喉。因为细胞是通关蛋白质相互沟通的，所以它假扮成蛋白质诱骗细胞导致感染。而感染的细胞开始复制病毒，最新的病毒被复制，开始诱骗更多的细胞，以此往复。\n3. 由于被感染的细胞越来越多，以至于被**巡逻兵（中性粒细胞）**发现了。它们带着更多的人手杀死病毒和被感染的细胞，但是战争就是残酷的，双方都有伤亡。\n4. 当第一战打完后，**清洁车（巨噬细胞）**就开始清理战场了，事实上它的动作是很粗鲁的，以至于我们感觉到喉咙痛也是因为它们所导致的。而后巨噬细胞释放**白细胞介素**，这种化学信号会导致你感到疼痛乏力，提醒你生病了。更主要是调节你脑壳里的**恒温器（体温调节中枢，维持37°度的神器）**，那病毒跟我们一样在天气热的时候工作效率会变低。\n5. 值得庆幸的是我们有**情报员（树突状细胞）**收集病毒碎片信息，当收集到足够的信息后送往**军备库（淋巴腺）**，得到信息的军备库马上开始配备对付病毒的**T细胞**和**B细胞**，并前往战场精准的消灭病毒和感染细胞及抑制新病毒再次感染细胞。\n6. 通过咳嗽以及其他办法排出残骸后，病毒彻底被消灭后。\n\n当新的咽喉细胞重新生长，你的感冒就痊愈了。\n\n## 病毒（virus）\n\n一种只含**DNA**或**RNA**的遗传因子，因为颗粒极小能通过细菌滤器，又称**滤过性病毒**。\n\n流感病毒就属于RNA病毒，和最近爆发**疫情（冠状病毒）**一样也是RNA病毒，大致长这样：\n\n![RNA病毒](/blog/image/virus/RNA_Virus.jpg)\n> 工作流就是一系列 RNA 的转录，复制，最后组装成熟而释放出来，再继续感染其他细胞\n","tags":["常识"]},{"title":"阅读笔记 | 鲁迅","url":"/blog/2020/09/28/周树人的故事/","content":"\n![周树人](/blog/image/shuren/zhoushuren.jpg)\n\n## 时间跨度\n\n- 光绪 七年 - 三十四年（1881 - 1908）\n- 宣统 元年 - 二年（1909 - 1910）\n- 民国 元年 - 二十五年（1912 - 1936）\n\n## 经历\n\n- 1881年出生于**浙江省绍兴府会稽县府城内东昌坊口（今属绍兴市越城区）**的书香门第，名为**周樟寿**。\n- 1892年（11岁）就读于**寿镜吾先生**开设的**私塾（补习班）**`三味书屋`，课余时间画画，结交**闰土（章闰水）**为好友。\n- 1893年（12岁）**祖父（周福清）**因向主考官行贿被举报而被革职下狱，此案判处了**斩立决**，为祖父得以活命疏通官府，这也成了家族衰弱的原因。同年**父亲（周伯宜）**也重病在床。\n- 1896年（15岁）父亲病故，家庭变故（后因分房拒绝签字遭叔辈斥责）。\n- 1898年（17岁）4月，离开家乡进入**金陵（免学费）**江南水师学堂。因远房的叔祖**周庆蕃**在这所学校教汉文，兼当管轮堂监督。并改名为**周树人**。后来的回忆里以**乌烟瘴气**来形容这段经历，教师思想太陈旧太迷信，只会照本宣科。同年10月，转考入南京矿务铁路学堂`为江南陆师学堂附设`，简称**矿路学堂（该学堂实际上也就招生了一届，共24人）**。\n- 1899年（18岁）2月开学，与**陈衡恪**结识。学校主要目的是采煤，所以学校的功课以矿务为主。自学了《全体新论》和《化学卫生论》，和先前父亲生病时医生的议论和方药比较起来，便觉得`中医不过是一种有意的或无意的骗子`。在校三年的学习中，掌握了德语；刻苦的整本抄地质学的讲义，学了些科学知识；喜欢看时务报，也受到维新和革命的影响；学习了《矿学》、《地质学》、《测算学》和《测图学》等课程，考试成绩优秀。\n- 1902年（21岁）1月毕业时获得金质奖章。毕业后考取了**南京矿路学堂毕业奏奖五品顶戴**的官费对日留学生。**鲁迅**觉得自己学无所成，接下来只有出国求学这一条路。因**成城学校（日本为留学生开设的一所陆军士官预备学校）**审批未能通过，先入**东京弘文学院（日语速成学院）**，入编江南班，**鲁迅**是江南班第一个剪掉辫子的。\n- 1903年（22岁）以`索子`为笔名发表《中国地质略论》，在《月界旅行》的序言《说鈤》一文中提及到化学元素**镭**，距**玛丽·居里**获得诺贝尔奖只隔了半年。\n- 1904年（23岁）从**东京弘文学院**毕业，按理升入**东京帝国大学**工科所属的采矿冶金科学习，但是决定学医，于是选择去**仙台医学专门学校**，成为该校第一个中国留学生且免学费，给他印象最深的是解剖学老师**藤野严九郎**。年底成为**光复会**第一批会员。\n- 1906年（25岁）在医专课堂上观看老师播放的日俄战争的幻灯片，中国人给沙俄当坐探，被日军逮捕以间谍罪枪毙砍头，那时候意识到`医学并非一件紧要事，第一要著是改变国民的精神`，于是决定弃医从文。被母亲**鲁瑞**用`母病速归`的电报召回，遵照母亲的意愿和**朱安**结婚，但一生几乎未与朱安有夫妻之实。\n- 1908年（27岁）**章太炎**流亡东京，**鲁迅**成为**章太炎**的学生。\n- 1909年（28岁）8月回国，担任杭州、浙江两级师范学堂（今杭州高级中学）优级生理学、初级化学教员。后写出第一篇小说《怀旧》。\n- 1918年（37岁）周树人首次用`鲁迅`为笔名，在《新青年》上发表中国史上第一篇用现代形式创作的短篇白话文小说《狂人日记》。\n- 1921年（40岁）发表中篇小说《阿Q正传》。\n- 1923年（42岁）7月18日，周作人写信与鲁迅绝交，随后鲁迅搬到砖塔胡同居住。\n- 1924年（43岁）鲁迅、周作人、林语堂、钱玄同等人创办同人周刊《语丝》。\n- 1926年（45年）**三一八惨案**爆发后，易培基（好友）等都被中华民国临时执政段祺瑞通缉。同年8月，因支持北京学生爱国运动，抗议**三一八惨案**，对北洋政府失望，南下厦门大学任文科教授。\n- 1927年（46岁）1月离开厦门，去往广州于广州中山大学任文学系主任兼教务主任，并与许广平同居。同年4月蒋介石发动政变（四一二事变），来到上海的鲁迅开始批判国民政府。\n- 1930年（49岁）2月**鲁迅**等人在上海成立中国自由运动大同盟。\n- 1931年（50岁）大力倡导木刻版画。\n- 1932年（51岁）淞沪战争爆发，同年1月鲁迅和周建人两家共十口人躲进鲁迅的密友内山完造创办的内山书店的三楼避难。同年2月和周建人一家以及仆人等十人又到英租界内的内山书店分店避难。4月，内山完造以内山书店职员的名义替鲁迅租下大陆新村的住所，自4月11日至逝世前一直居住于此。\n- 1936年（55岁）10月19日上午5时25分在上海因肺结核病逝世。\n\n## 小说集与分篇\n\n- 呐喊\n  - 狂人日记\n  - 孔乙己\n  - 药\n  - 明天\n  - 一件小事\n  - 头发的故事\n  - 风波\n  - 故乡\n  - 阿Q正传\n  - 端午节\n  - 白光\n  - 兔和猫\n  - 鸭的喜剧\n  - 社戏\n- 彷徨\n  - 祝福\n  - 在酒楼上\n  - 幸福的家庭\n  - 肥皂\n  - 长明灯\n  - 示众\n  - 高老夫子\n  - 孤独者\n  - 伤逝\n  - 弟兄\n  - 离婚\n- 故事新编\n\n## 美术设计作品\n\n![猫头鹰](/blog/image/shuren/maotouying.jpg)\n<center>图为：猫头鹰</center>\n\n![猫头鹰](/blog/image/shuren/maotouying2.jpg)\n<center>图为：猫头鹰</center>\n\n![校徽](/blog/image/shuren/xiaohui.jpg)\n<center>图为：校徽</center>\n\n![国徽](/blog/image/shuren/guohui.jpg)\n<center>图为：国徽</center>\n\n## 照片\n\n![鲁迅本人](/blog/image/shuren/zhoushuren01.jpg)\n<center>1928年3月22日摄于景云里寓中</center>\n\n![全家福](/blog/image/shuren/all.jpg)\n<center>1931年4月20日，鲁迅全家与冯雪峰全家摄于上海。鲁迅抱着周海婴，身后是许广平。</center>\n\n![鲁迅笑](/blog/image/shuren/zhoushuren02.jpg)\n<center>沙飞摄于1936年10月8日，鲁迅生平不苟言笑，这是鲁迅照片中唯一大笑的镜头</center>","tags":["人物介绍"]},{"title":"CentOs 安装 Redis","url":"/blog/2020/06/12/CentOs安装Redis/","content":"\n## 安装环境\n\n系统：CentOS Linux release 8.1.1911 (Core) | Redis版本：6.0.5 | 博客记录时间：2020-6-12 17:15:04\n\n## 下载最新稳定版\n\n```shell\n# 下载当前最新版\nwget http://download.redis.io/releases/redis-6.0.5.tar.gz\n# 解压\ntar -zxvf redis-6.0.5.tar.gz\n# 进入到解压后的文件夹\ncd redis-6.0.5\n```\n\n## 安装 Redis\n\n```shell\n# 编译前先确保安装了gcc和make\nyum install -y gcc make\n# 编译(当前位置在redis-6.0.5中)\nmake\n# 编译结果如下：\n\t一堆的CC编译\n    LINK redis-server\n    INSTALL redis-sentinel\n    LINK redis-cli\n    LINK redis-benchmark\n    INSTALL redis-check-rdb\n    INSTALL redis-check-aof\nHint: It's a good idea to run 'make test' ;)\n-------------------------------------------------------------------------\n# 如果 make 失败，可以试着升级 gcc 版本\nyum -y install centos-release-scl\nyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils\n# 切换到高版本，然后继续 make 的步骤\nscl enable devtoolset-9 bash\n-------------------------------------------------------------------------\n# 进入到src目录\ncd src\n# 安装\nmake install\n# 输出内容如下：\n    INSTALL install\n    INSTALL install\n    INSTALL install\n    INSTALL install\n    INSTALL install\n# 运行redis-server\nredis-server\n# 输出内容如下说明，安装成功：\nIn order to specify a config file use redis-server /path/to/redis.conf\nIncreased maximum number of open files to 10032 (it was originally set to 1024).\n---\nRedis 6.0.5 (00000000/0) 64 bit\nRunning in standalone mode\nPort: 6379\nPID: 7303\nhttp://redis.io\n---\n...\nLoading RDB produced by version 6.0.5\nRDB age 885 seconds\nRDB memory usage when created 0.77 Mb\nDB loaded from disk: 0.000 seconds\nReady to accept connections\n```\n\n## 配置 Redis\n\n在初次接触前我们尤其要注意三个文件：\n\n- redis-6.0.5\n  - redis.conf  `(配置文件)`\n  - src\n    - redis-server `(Redis 服务)`\n    - redis-cli `(Redis 客户端)`\n\n```shell\n# 用 vim 打开 redis.conf\nvim redis.conf\n# 开启守护进程：\ndaemonize yes\n# 允许任何网络接口连接\nbind 127.0.0.1 修改为 bind 0.0.0.0\n# 连接密码授权\nrequirepass [你的密码]\n# 当然除了在配置中设置密码，你还可以在客户端设置密码\nconfig set requirepass [你的密码]\n# 其他的一些配置,如修改默认端口(6379)\nport 6379\n```\n\n## 配置Redis服务\n\n```shell\n# 在/etc目录下新建redis目录\nmkdir redis\n# 复制一份 redis.conf 文件到 /etc/redis 目录下，并命名为6379.conf\ncp ./redis.conf /etc/redis/6379.conf\n# 复制一份启动脚本到 /etc/init.d 目录下\ncp ./utils/redis_init_script /etc/init.d/redisd\n# 编辑 redisd 文件\nvim /etc/init.d/redisd\n# 在第一行后加上下面两句注释语句（为了支持 chkconfig ）\n# chkconfig:   2345 90 10\n# description:  Redis is a persistent key-value database\n```\n\n> 注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10\n\n## 设置开机自启\n\n```shell\n# 设置服务开机自启\nchkconfig redisd on\n# 开启服务\nsystemctl start redisd\n# 查看 redis 服务是否启动\nsystemctl status redisd\n# 显示 active (running) 说明启动正常\nredisd.service - LSB: Redis data structure server\n   Loaded: loaded (/etc/rc.d/init.d/redisd; bad; vendor preset: disabled)\n   Active: active (running) since Thu 2021-06-24 16:48:09 CST; 20min ago\n     Docs: man:systemd-sysv-generator(8)\n  Process: 6303 ExecStop=/etc/rc.d/init.d/redisd stop (code=exited, status=0/SUCCESS)\n  Process: 6392 ExecStart=/etc/rc.d/init.d/redisd start (code=exited, status=0/SUCCESS)\n   CGroup: /system.slice/redisd.service\n           └─6394 /usr/local/bin/redis-server 0.0.0.0:6379\n```\n## 创建软链\n\n如果步骤中 make 失败，可能会存在一个问题就是 redis-cli 或 redis-server 链接没有被创建，这个时候你要自己创建链接方便自己日后使用：\n```shell\n# 使用 ln 指令设置硬链接，[redis folder] 替换成你安装 redis 的目录（绝对路径）\nln [redis folder]/src/redis-cli /usr/sbin/redis-cli\nln [redis folder]/src/redis-server /usr/sbin/redis-server\n\n# 使用 ln -s 参数在登录目录中为 redis 文件夹设置软链接（-s = symbolic），[target folder] 替换成你要放置软链的目录，按自己需求设置\nln -s [redis folder]/ [target folder]/redis\n# 设置完之后你可以 [target folder] 中直接 cd 到 redis，使用 ls -l 指令可以看出链接对应的目标，大致如下：\nlrwxrwxrwx 1 root root   23 Jul  1 09:18 redis -> /usr/redis/redis-6.0.5/\n```\n\n## 相关文档\n\n- [Redis Archived Versions](http://download.redis.io/releases/)\n- [CentOs7 下安装 Redis](https://www.cnblogs.com/zuidongfeng/p/8032505.html)","tags":["Redis"]},{"title":"Tomcat 部署项目时遇到的问题","url":"/blog/2020/04/23/Tomcat部署项目时遇到的问题/","content":"\n## 1.Unable to add the resource\n>org.apache.catalina.webresources.Cache.getResource Unable to add the resource\n\n**原因：**资源缓存空间不足，得配置更大的资源缓存空间\n\n**解决方法：**修改 Tomcat 文件夹下 conf 文件中的 context.xml 文件，添加内容如下：\n\n```xml\n<Context>\n\t<Resources cachingAllowed=\"true\" cacheMaxSize=\"150000\" ></Resources>\n</Context>\n```\n\n## 2.naming.namingContextCreationFailed\n>org.apache.catalina.core.NamingContextListener.lifecycleEvent naming.namingContextCreationFailed\n\n**原因**：命名监听器创建失败\n\n### 3.至少有一个JAR被扫描用于TLD但尚未包含TLD。\n>org.apache.jasper.servlet.TldScanner.scanJars 至少有一个JAR被扫描用于TLD但尚未包含TLD。 为此记录器启用调试日志记录，以获取已扫描但未在其中找到TLD的完整JAR列表。 在扫描期间跳过不需要的JAR可以缩短启动时间和JSP编译时间。\n\n**等级：**警告\n\n**解决方法:**\n\n**1.修改 Tomcat 文件夹下 conf 文件夹中 logging.properties 文件**\n\n```properties\n# 输出被扫描TLD的Jar包的列表\norg.apache.jasper.servlet.TldScanner.level = FINE\n```\n\n**2.重新运行 Tomcat ，日志输出扫描的Jar包**\n\n**3.修改 Tomcat 文件夹下 conf 文件夹中 catalina.properties 文件**\n\n```properties\n# Default list of JAR files that should not be scanned using the JarScanner\n# functionality. This is typically used to scan JARs for configuration\n# information. JARs that do not contain such information may be excluded from\n# the scan to speed up the scanning process. This is the default list. JARs on\n# this list are excluded from all scans. The list must be a comma separated list\n# of JAR file names.\n# The list of JARs to skip may be over-ridden at a Context level for individual\n# scan types by configuring a JarScanner with a nested JarScanFilter.\n# The JARs listed below include:\n# - Tomcat Bootstrap JARs\n# - Tomcat API JARs\n# - Catalina JARs\n# - Jasper JARs\n# - Tomcat JARs\n# - Common non-Tomcat JARs\n# - Test JARs (JUnit, Cobertura and dependencies)\ntomcat.util.scan.StandardJarScanFilter.jarsToSkip=\\\nannotations-api.jar,\\ant-junit*.jar,\\ant-launcher.jar,\\\nant.jar,\\asm-*.jar,\\aspectj*.jar,\\bootstrap.jar,\\catalina-ant.jar,\\catalina-ha.jar,\\\ncatalina-ssi.jar,\\catalina-storeconfig.jar,\\catalina-tribes.jar,\\catalina.jar,\\cglib-*.jar,\\\ncobertura-*.jar,\\commons-beanutils*.jar,\\commons-codec*.jar,\\commons-collections*.jar,\\\ncommons-daemon.jar,\\commons-dbcp*.jar,\\commons-digester*.jar,\\\ncommons-fileupload*.jar,\\commons-httpclient*.jar,\\commons-io*.jar,\\commons-lang*.jar,\\\ncommons-logging*.jar,\\commons-math*.jar,\\commons-pool*.jar,\\dom4j-*.jar,\\easymock-*.jar,\\\necj-*.jar,\\el-api.jar,\\geronimo-spec-jaxrpc*.jar,\\h2*.jar,\\hamcrest-*.jar,\\hibernate*.jar,\\\nhttpclient*.jar,\\icu4j-*.jar,\\jasper-el.jar,\\jasper.jar,\\jaspic-api.jar,\\jaxb-*.jar,\\\njaxen-*.jar,\\jdom-*.jar,\\jetty-*.jar,\\jmx-tools.jar,\\jmx.jar,\\jsp-api.jar,\\jstl.jar,\\\njta*.jar,\\junit-*.jar,\\junit.jar,\\log4j*.jar,\\mail*.jar,\\objenesis-*.jar,\\oraclepki.jar,\\\noro-*.jar,\\servlet-api-*.jar,\\servlet-api.jar,\\slf4j*.jar,\\taglibs-standard-spec-*.jar,\\\ntagsoup-*.jar,\\tomcat-api.jar,\\tomcat-coyote.jar,\\tomcat-dbcp.jar,\\tomcat-i18n-*.jar,\\\ntomcat-jdbc.jar,\\tomcat-jni.jar,\\tomcat-juli-adapters.jar,\\tomcat-juli.jar,\\tomcat-util-scan.jar,\\\ntomcat-util.jar,\\tomcat-websocket.jar,\\tools.jar,\\websocket-api.jar,\\wsdl4j*.jar,\\xercesImpl.jar,\\\nxml-apis.jar,\\xmlParserAPIs-*.jar,\\xmlParserAPIs.jar,\\xom-*.jar\n# 将要跳过扫描的包在后面添加\n# 例子：mysql-connector-*.jar,\\\n# 注意以 ,\\ 分隔\n```","tags":["Bug"]},{"title":"Tomcat 服务","url":"/blog/2020/04/23/Tomcat服务/","content":"\n## 环境\n\n运行环境：Windows 10 | Apache Tomcat 9.0.34 | 博客记录时间：2020-4-23 17:16:12\n\n通常我们 打开 / 关闭 Tomcat 服务时都会执行bin目录下的 startup.bat / shutdown.bat 文件。\n\n但是细心的小伙伴就会发现(╮(￣▽￣)╭)，`startup.bat` 和 `shutdown.bat` 文件中都有这么一句话。\n\n```bash\nrem ---------------------------------------------------------------------------\nrem Start / Stop script for the CATALINA Server\nrem ---------------------------------------------------------------------------\ncall \"%EXECUTABLE%\" start / stop %CMD_LINE_ARGS%\n```\n\n所以不论是 startup 还是 shutdown 都是执行了 `catalina.bat`，只是执行的指令不同。\n\n## catalina.bat\n\n首选我们分析下 `catalina.bat` 脚本的内容：\n\n```bash\nrem Guess CATALINA_HOME if not defined\nset \"CURRENT_DIR=%cd%\"\nif not \"%CATALINA_HOME%\" == \"\" goto gotHome\nset \"CATALINA_HOME=%CURRENT_DIR%\"\nif exist \"%CATALINA_HOME%\\bin\\catalina.bat\" goto okHome\ncd ..\nset \"CATALINA_HOME=%cd%\"\ncd \"%CURRENT_DIR%\"\n```\n\n检验 CATALINA_HOME 环境变量，如果不正确则重新设置。\n\n```bash\nset CLASSPATH=\n\nrem Get standard environment variables\nif not exist \"%CATALINA_BASE%\\bin\\setenv.bat\" goto checkSetenvHome\ncall \"%CATALINA_BASE%\\bin\\setenv.bat\"\ngoto setenvDone\n:checkSetenvHome\nif exist \"%CATALINA_HOME%\\bin\\setenv.bat\" call \"%CATALINA_HOME%\\bin\\setenv.bat\"\n:setenvDone\n\nrem Get standard Java environment variables\nif exist \"%CATALINA_HOME%\\bin\\setclasspath.bat\" goto okSetclasspath\necho Cannot find \"%CATALINA_HOME%\\bin\\setclasspath.bat\"\necho This file is needed to run this program\ngoto end\n:okSetclasspath\ncall \"%CATALINA_HOME%\\bin\\setclasspath.bat\" %1\nif errorlevel 1 goto end\n```\n\n设置环境变量：\n\n- 在 CATALINA_BASE 和 CATALINA_BASE 寻找`setenv.bat`文件并执行，找不到则不执行。\n- 寻找`setclasspath.bat`(设置 Java 相关的环境变量)文件并执行，找不到则结束。\n\n```bash\nrem Add tomcat-juli.jar to classpath\nrem tomcat-juli.jar can be over-ridden per instance\nif not exist \"%CATALINA_BASE%\\bin\\tomcat-juli.jar\" goto juliClasspathHome\nset \"CLASSPATH=%CLASSPATH%;%CATALINA_BASE%\\bin\\tomcat-juli.jar\"\ngoto juliClasspathDone\n:juliClasspathHome\nset \"CLASSPATH=%CLASSPATH%;%CATALINA_HOME%\\bin\\tomcat-juli.jar\"\n:juliClasspathDone\n\nif not \"%JSSE_OPTS%\" == \"\" goto gotJsseOpts\nset \"JSSE_OPTS=-Djdk.tls.ephemeralDHKeySize=2048\"\n:gotJsseOpts\nset \"JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%\"\n\nrem Register custom URL handlers\nrem Do this here so custom URL handles (specifically 'war:...') can be used in the security policy\nset \"JAVA_OPTS=%JAVA_OPTS% -Djava.protocol.handler.pkgs=org.apache.catalina.webresources\"\n\nif not \"%LOGGING_CONFIG%\" == \"\" goto noJuliConfig\nset LOGGING_CONFIG=-Dnop\nif not exist \"%CATALINA_BASE%\\conf\\logging.properties\" goto noJuliConfig\nset LOGGING_CONFIG=-Djava.util.logging.config.file=\"%CATALINA_BASE%\\conf\\logging.properties\"\n:noJuliConfig\n\nif not \"%LOGGING_MANAGER%\" == \"\" goto noJuliManager\nset LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n:noJuliManager\n```\n\ntomcat-juli.jar：\n\n- 将 **tomcat-juli.jar** 添加到 classPath 环境变量中。\n- 将日志的配置文件路径添加到 LOGGING_CONFIG 环境变量中。\n\n> Apache Tomcat由一个自己的实现了 java.util.logging 多个关键元素的实现。这个实现被称为 JULI 。实现的核心组件是定制化的 LogManager ，可以获取运行在Tomcat中的不同web应用(以及不同的class loader)。他支持为应用配置单独的日志配置。当有web应用从内在中是被卸载时，会接到Tomcat的通知，以便他所引用的类可以被清除，避免内存泄露。\n\n```bash\nrem Execute The Requested Command\necho Using CATALINA_BASE:   \"%CATALINA_BASE%\"\necho Using CATALINA_HOME:   \"%CATALINA_HOME%\"\necho Using CATALINA_TMPDIR: \"%CATALINA_TMPDIR%\"\nif \"\"%1\"\" == \"\"debug\"\" goto use_jdk\necho Using JRE_HOME:        \"%JRE_HOME%\"\ngoto java_dir_displayed\n:use_jdk\necho Using JAVA_HOME:       \"%JAVA_HOME%\"\n:java_dir_displayed\necho Using CLASSPATH:       \"%CLASSPATH%\"\n\nset _EXECJAVA=%_RUNJAVA%\nset MAINCLASS=org.apache.catalina.startup.Bootstrap\nset ACTION=start\nset SECURITY_POLICY_FILE=\nset DEBUG_OPTS=\nset JPDA=\n\nif not \"\"%1\"\" == \"\"jpda\"\" goto noJpda\nset JPDA=jpda\nif not \"%JPDA_TRANSPORT%\" == \"\" goto gotJpdaTransport\nset JPDA_TRANSPORT=dt_socket\n:gotJpdaTransport\nif not \"%JPDA_ADDRESS%\" == \"\" goto gotJpdaAddress\nset JPDA_ADDRESS=localhost:8000\n:gotJpdaAddress\nif not \"%JPDA_SUSPEND%\" == \"\" goto gotJpdaSuspend\nset JPDA_SUSPEND=n\n:gotJpdaSuspend\nif not \"%JPDA_OPTS%\" == \"\" goto gotJpdaOpts\nset JPDA_OPTS=-agentlib:jdwp=transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND%\n:gotJpdaOpts\nshift\n:noJpda\n```\n\n- 设置启动类 - org.apache.catalina.startup.Bootstrap\n- 设置远程调试相关参数 - JPDA\n\n```bash\nif \"\"%1\"\" == \"\"debug\"\" goto doDebug\nif \"\"%1\"\" == \"\"run\"\" goto doRun\nif \"\"%1\"\" == \"\"start\"\" goto doStart\nif \"\"%1\"\" == \"\"stop\"\" goto doStop\nif \"\"%1\"\" == \"\"configtest\"\" goto doConfigTest\nif \"\"%1\"\" == \"\"version\"\" goto doVersion\n\necho Usage:  catalina ( commands ... )\necho commands:\necho   debug             Start Catalina in a debugger\necho   debug -security   Debug Catalina with a security manager\necho   jpda start        Start Catalina under JPDA debugger\necho   run               Start Catalina in the current window\necho   run -security     Start in the current window with security manager\necho   start             Start Catalina in a separate window\necho   start -security   Start in a separate window with security manager\necho   stop              Stop Catalina\necho   configtest        Run a basic syntax check on server.xml\necho   version           What version of tomcat are you running?\ngoto end\n```\n\n这里值得注意的且常用的(start / stop)，正如开头提到的。\n\n## org.apache.catalina\n\n解压 bin 目录中的 catalina.jar 后我们能找到 org.apache.catalina.startup.Bootstrap 也就是 catalina.bat 里设置的启动类(MAINCLASS)\n\n```java\npackage org.apache.catalina.startup;\npublic final class Bootstrap {\n    public static void main(String[] args) {\n        // --- 略 ---\n        String command = \"start\";\n        if (args.length > 0) {\n            command = args[args.length - 1];\n        }\n        if (command.equals(\"start\")) {\n            daemon.setAwait(true);\n            daemon.load(args);\n            daemon.start();\n            if (null == daemon.getServer()) {\n                System.exit(1);\n            } else if (command.equals(\"stop\")) {\n                daemon.stopServer(args);\n            }\n        }\n        // --- 略 ---\n    }\n}\n```\n\n当指令等于`start`时运行 Catalina.class 中的 `start()`方法：\n\n```java\npackage org.apache.catalina.startup;\n\npublic class Catalina {\n    public void start() {\n        // --- 略 ---\n        if (this.await) {\n            this.await();\n            this.stop();\n        }\n    }\n}\n```\n\n在`start()`方法中调用了`await()`和`stop()`两个方法：\n\n- `await()` 方法监听停止服务请求的方法\n\n- `stop()` 方法是停止服务的方法\n\n> `await()` 方法是阻塞方法，只有客户端请求关闭Tomcat服务时，他才会执行`stop()`方法，否则一直等待关闭请求。\n\nStandardServer.class 中的 `await()` 方法：\n\n```java\npackage org.apache.catalina.core;\n\npublic final class StandardServer extends LifecycleMBeanBase implements Server {\n    private volatile ServerSocket awaitSocket = null;\n    private String shutdown = \"SHUTDOWN\";\n    \n    public void await() {\n        /* 略 */\n        try {\n            this.awaitSocket = new ServerSocket(this.getPortWithOffset(), 1,InetAddress.getByName(this.address));\n        } catch (IOException var67) {\n            log.error(sm.getString(\"standardServer.awaitSocket.fail\", new Object[]{this.address,String.valueOf(this.getPortWithOffset()), String.valueOf(this.getPort()),String.valueOf(this.getPortOffset())}), var67);\n            return;\n        }\n        ServerSocket serverSocket;\n        try {\n            /* 略 */\n             while(true) {\n                 label611: {\n                     label610: {\n                         try {\n                             label634: {\n                                 try {\n                                     // 执行accept等待请求\n                                     socket = serverSocket.accept();\n                                     socket.setSoTimeout(10000);\n                                     stream = socket.getInputStream();\n                                 } catch (SocketTimeoutException var69) {\n                                     log.warn(sm.getString(\"standardServer.accept.timeout\", new Object[]{System.currentTimeMillis() - acceptStartTime}), var69);\n                                     continue;\n                                 }\n                                 /* 略 */\n                             }\n                         }\n                     }\n                 }\n                 /* 略 */\n                 boolean match = command.toString().equals(this.shutdown);\n                 // 如果请求内容与 shutdown 字段相同则跳出循环，Socket 服务停止\n                 if (match) {\n                     log.info(sm.getString(\"standardServer.shutdownViaPort\"));\n                     var32 = false;\n                     break;\n                 }\n                 log.warn(sm.getString(\"standardServer.invalidShutdownCommand\", new Object[]{command.toString()}));\n             }\n        }\n        /* 略 */\n    }\n}\n```\n\n可以看到这里开启了一个 ServerSocket ，调用 accept() 方法监听请求。\n\n`serverSocket.close()`之后 `start()`方法中的`this.stop()`执行，Server 被关闭。\n\n当指令等于`stop`时运行 Catalina.class 中的 `stopServer()`方法：\n\n```java\npublic void stopServer(String[] arguments) {\n    if (arguments != null) {\n        this.arguments(arguments);\n    }\n    Server s = this.getServer();\n    if (s == null) {\n        /* 略 */\n    } else {\n        try {\n            s.stop();\n            s.destroy();\n        } catch (LifecycleException var63) {\n            log.error(sm.getString(\"catalina.stopError\"), var63);\n        }\n    }\n}\n```\n\n显而易见，Server 不为 null 时，停止并且销毁。\n\n## Server 中的 shutdown 属性\n\n```bash\n<Server port=\"8085\" shutdown=\"SHUTDOWN\">\n```\n\n这里`shutdown`的默认属性就是`SHUTDOWN`，与 StandardServer 类中 shutdown 属性的值一样。\n\n> 当然 StandardServer 类中 shutdown 属性提供了 setShutdown(String shutdown) 方法。\n\n做个测试，我们执行 startup.bat 先启动 Tomcat ，跳出窗口并打印日志：\n\n```bash\n┌────────────────────────────────────────────────────────┐\n│Tomcat\n├────────────────────────────────────────────────────────┤\n│Server.服务器版本:Apache Tomcat/9.0.34\n│服务器构建:Apr 3 2020 2020 12:02:52 UTC\n│服务器版本号(:9.0.34.0\n│# 略\n│Server startup in [673] milliseconds\n└────────────────────────────────────────────────────────┘\n```\n\n我们再启动另一个窗口，进入`telnet`：\n\n```\n┌────────────────────────────────────────────────────────┐\n│Command Prompt\n├────────────────────────────────────────────────────────┤\n│Microsoft Windows [版本 10.0.17763.1039]\n│(c) 2018 Microsoft Corporation。保留所有权利。\n│C:\\Users\\Administrator>telnet localhost 8005\n│正在连接localhost...\n└────────────────────────────────────────────────────────┘\n```\n\n之后我们再像8005端口发送点东西\n\n```\n┌────────────────────────────────────────────────────────┐\n│Telnet localhost\n├────────────────────────────────────────────────────────┤\n│unshell\n└────────────────────────────────────────────────────────┘\n```\n\n发送`unshell`字符串，Tomcat窗口打印出新的内容\n\n```\n┌────────────────────────────────────────────────────────┐\n│Tomcat\n├────────────────────────────────────────────────────────┤\n│Server.服务器版本:Apache Tomcat/9.0.34\n│服务器构建:Apr 3 2020 2020 12:02:52 UTC\n│服务器版本号(:9.0.34.0\n│# 略\n│Server startup in [673] milliseconds\n│Invalid shutdown command [unshell] received\n└────────────────────────────────────────────────────────┘\n```\n\n如果内容没有更新可以尝试按`enter`键\n\n```verilog\n# 完整内容如下(可以看到警告的方法，就如我们之前所说的那样)\n23-Apr-2020 16:57:20.166 警告 [main] org.apache.catalina.core.StandardServer.await Invalid shutdown command [unshell] received\n```\n\n所以当我们输入指令为`SHUTDOWN`时，Tomcat 就关闭了。\n\n当然这个指令默认监听`localhost`的关闭请求，如果要支持远程关闭的话，可以添加参数 address，例子如下：\n\n```bash\n<Server port=\"8085\" shutdown=\"SHUTDOWN\" address=\"36.152.44.95\">\n```\n\n具体版本是否支持该参数，运行 Tomcat ，文档在 `http://localhost:8080/docs/config/server.html`中有说明。\n\n这里以版本9为例\n\nAll implementations of **Server** support the following attributes：\n\n| Attribute | Description                                                  |\n| --------- | ------------------------------------------------------------ |\n| port      | The TCP/IP port number on which this server waits for a shutdown command. Set to `-1` to disable the shutdown port. |\n| shutdown  | The command string that must be received via a TCP/IP connection to the specified port number, in order to shut down Tomcat. |\n| address   | The TCP/IP address on which this server waits for a shutdown command. If no address is specified, `localhost` is used. |\n\n> 以上就是所有内容，本文只是在理解 Tomcat 时，碰巧看到的一些边缘内容，作为记录保存下来。\n\n## 引文\n\n- [Tomcat catalina.bat 原理解析](https://www.jianshu.com/p/b2f63ffa964c)\n\n- [Tomcat 怎么停止服务的?](https://cloud.tencent.com/developer/article/1129737)","tags":["Tomcat"]},{"title":"Tomcat入门使用","url":"/blog/2020/04/23/快速使用Tomcat/","content":"\n## 环境\n\n运行环境：Windows 10 | Apache Tomcat 9.0.34 | Java 1.8.0 | 博客记录时间：2020-4-23 08:59:27\n\n## 下载 Tomcat\n\n首先进入到 [Tomcat官网](http://tomcat.apache.org/) ，这里我们以 [版本9](https://tomcat.apache.org/download-90.cgi) 进行举例 (目前最新版本为10)。\n\n## 9.0.34\n\n### Binary Distributions\n\n- Core:\n  - [zip](https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.zip) ([pgp](https://downloads.apache.org/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.zip.asc), [sha512](https://downloads.apache.org/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.zip.sha512))\n\n这里我们直接点击 zip 下载，下载完之后文件目录如下：\n\n- apache-tomcat-9.0.34\n  - bin - 运行文件，Windows环境下的.bat和Linux环境下的.sh\n  - conf - 常用到的一些配置文件\n  - lib - 一些 Java 的 Jar 包\n  - logs - 日志\n  - temp - 临时文件\n  - webapps - 默认虚拟主机的默认项目根目录\n  - work - 项目部署后的缓存文件目录\n\n除了以前的文件夹外还有一些文件，如 README.md 文件\n\n> 官网：Please see the README file for packaging information. It explains what every distribution contains. \n\n## 运行 Tomcat\n\n我们可以看到 webapps 目录下有5个初始项目：\n\n- webapps\n  - docs\n  - examples\n  - host-manager\n  - manager\n  - ROOT\n\n> Tomcat 中 bin 和 lib 文件中的 Jar 包说明了需要在 Java 环境下运行\n\n然后我们运行 bin 目录下的 startup.bat 文件，如果出现终端窗口一直在打印日志说明运行成功：\n\n```bash\n┌────────────────────────────────────────────────────────┐\n│Command Prompt\n├────────────────────────────────────────────────────────┤\n│Server.服务器版本:Apache Tomcat/9.0.34\n│服务器构建:Apr 3 2020 2020 12:02:52 UTC\n│服务器版本号(:9.0.34.0\n│OS Name:Windows 10\n│OS.版本:10.0\n│架构:amd64\n│Java 环境变量: C:\\Program Files\\Java\\jdk1.8.0_251\\jre\n│JVM 版本:1.8.0_251-b08\n│JVM.供应商:Oracle Corporation\n│--- 略 ---\n└────────────────────────────────────────────────────────┘\n```\n\n打印的内容大致如上，这时候使用浏览器访问 `localhost:8080`，就能看到 Tomcat 的如下页面：\n\n![webapps 目录下的 ROOT 项目](/blog/image/tomcat/01.png)\n\n> 值得注意的是 work 目录中生成了对应项目的文件夹，但内容为空。以及 logs 文件中生成的日志文件，如 catalina.*.log 中的内容就是终端窗口打印的内容。\n\n## 日志输出乱码问题\n\n当窗口运行时输出的日志出现乱码，如`淇℃伅`之类的内容说明当前系统的默认字符与 conf 文件夹中 logging.properties 文件中 encoding 属性设置不相同(默认配置为UTF-8)。\n\n### 解决方法\n\n```bash\n┌────────────────────────────────────────────────────────┐\n│Command Prompt\n├────────────────────────────────────────────────────────┤\n│Microsoft Windows [版本 10.0.17763.1039]\n│(c) 2018 Microsoft Corporation。保留所有权利。\n│C:\\Users\\Administrator>chcp\n│活动代码页: 936\n└────────────────────────────────────────────────────────┘\n```\n\n获取当前系统活动代码页，找到对应编码，如下表：\n\n| 活动代码页 | 编码          |\n| ---------- | ------------- |\n| 936        | 简体中文(GBK) |\n| 65001      | UTF-8Unicode  |\n\n然后修改 logging.properties 中 encoding = GBK，如下：\n\n```properties\n############################################################\n# Handler specific properties.\n# Describes specific configuration info for Handlers.\n############################################################\n1catalina.org.apache.juli.AsyncFileHandler.level = FINE\n1catalina.org.apache.juli.AsyncFileHandler.directory = ${catalina.base}/logs\n1catalina.org.apache.juli.AsyncFileHandler.prefix = catalina.\n1catalina.org.apache.juli.AsyncFileHandler.maxDays = 90\n1catalina.org.apache.juli.AsyncFileHandler.encoding = GBK\n```\n\n## 发布项目\n\n### 1.添加 war 包到 webapps 中\n\n- webapps\n  - FlogShiro.war\n\n### 2.执行 startup.bat 文件 (如之前在执行状态先执行 shutdown.bat 文件)\n\n打印出日志，并且在webapps中解压war，多出项目文件夹：\n\n- webapps\n  - FlogShiro (解压的项目文件)\n  - FlogShiro.war\n\n### 3.访问网站\n\n`localhost:8080/FlogShiro/index.html`\n\n默认监听端口为`8080`，项目名为FlogShiro，展示页面为index.html\n\n> 具体内容根据实际情况决定\n\n## 配置\n\n目前我们还没提到 conf 文件夹，以发布项目中的例子查看 conf > server.xml 文件\n\n```xml\n<!-- 删除注解后内容如下 -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Server port=\"8005\" shutdown=\"SHUTDOWN\">\n  <Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" />\n  <Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" />\n  <Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" />\n  <Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" />\n  <Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" />\n\n  <GlobalNamingResources>\n    <Resource name=\"UserDatabase\" auth=\"Container\"\n              type=\"org.apache.catalina.UserDatabase\"\n              description=\"User database that can be updated and saved\"\n              factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\"\n              pathname=\"conf/tomcat-users.xml\" />\n  </GlobalNamingResources>\n\n  <Service name=\"Catalina\">\n    <Connector port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n    <Engine name=\"Catalina\" defaultHost=\"localhost\">\n      <Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n        <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"\n               resourceName=\"UserDatabase\"/>\n      </Realm>\n\n      <Host name=\"localhost\"  appBase=\"webapps\"\n            unpackWARs=\"true\" autoDeploy=\"true\">\n        <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n               prefix=\"localhost_access_log\" suffix=\".txt\"\n               pattern=\"%h %l %u %t &quot;%r&quot; %s %b\" />\n      </Host>\n    </Engine>\n  </Service>\n</Server>\n```\n\n这里我们值得注意的就是 `Server`、`Service` 和 `Connector` 以及 `Host`\n\n- Server\n  - port （服务器监听端口）\n  - shutdown (关闭指令)\n- Service\n  - name (服务名)\n- Connector\n  - port (服务监听端口)\n  - protocol (协议类型)\n  - connectionTimeout (连接超时)\n  - redirectPort (端口重定向)\n- Host\n  - name (虚拟主机名称)\n  - appBase (项目根目录)\n  - unpackWARs (解压War包)\n  - autoDeploy (自动部署)\n\n显而易见，以发布项目的例子可以看出名为 localhost 的虚拟主机的根目录为 webapps ，并且配置了解压 war 包，Service监听的端口为 `8080` 。\n\n所以当我们访问 `localhost:8080` 访问到了 webapps 目录下的ROOT，而访问 `localhost:8080/FlogShiro` 则访问到了指定FlogShiro项目。\n\n## 虚拟主机\n\n为什么我们访问 `localhost` 和 `127.0.0.1` 访问到的东西是一样，因为本机已经做好了IP和域名的本地映射\n\n找到 C:\\Windows\\System32\\drivers\\etc 中的`hosts`文件(C为系统盘)\n\n```\n# Copyright (c) 1993-2009 Microsoft Corp.\n#\n# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.\n#\n# This file contains the mappings of IP addresses to host names. Each\n# entry should be kept on an individual line. The IP address should\n# be placed in the first column followed by the corresponding host name.\n# The IP address and the host name should be separated by at least one\n# space.\n#\n# Additionally, comments (such as these) may be inserted on individual\n# lines or following the machine name denoted by a '#' symbol.\n#\n# For example:\n#\n#      102.54.94.97     rhino.acme.com          # source server\n#       38.25.63.10     x.acme.com              # x client host\n\n# localhost name resolution is handled within DNS itself.\n# 本地主机名称解析是在DNS本身内处理的。\n#\t127.0.0.1       localhost\n#\t::1             localhost\n```\n\n你可以按照上面的 `example` 添加虚拟主机名称，这样Tomcat配置文件夹下server.xml中Host属性name可以使用添加的主机名称。\n\n> 当然如果你不想在 webapps 中添加项目，你也可以新添加的主机中配置其他文件夹问根目录。\n>\n> 注意：在访问中(具体得看实际情况)，webapps 中可能存在一些会发生冲突的项目名，如 manager\n\n## 相关文档\n\n- [Apache Tomcat 9 (9.0.36) - Documentation Index](https://tomcat.apache.org/tomcat-9.0-doc/index.html)","tags":["Tomcat"]},{"title":"正则表达式","url":"/blog/2020/04/22/正则表达式/","content":"\n> 虽然正则内容不算很多但是用好正则还是得花一些时间的，这篇文章只是做简单的记录\n\n## 运算符类型\n\n- 转义符 ` /` \n- 圆括号和方括号 ` ()` 、` []` \n- 限定符 ` *` 、` +` 、`?` 、`{n}`、`{n,}`、` {n,m}` \n- 定位点和序列 ` ^` 、` $` 、` \\` \n- 替换，或操作 ` |` \n\n## 注意点\n\n以JavaScript为例使用正则的方法：\n- /[a-z]*/\n- ^[a-z]*$\n\n圆括号相当于子表达式，类似组的概念可以被重复使用\n- /\\b([a-z]+) \\1\\b/\n- /\\b([a-z]+) ([a-z]+)\\b/\n\n两者效果一样\n\n`^`虽然为定位符，但是在`[]`中起到非的作用\n\n## 推荐网站\n\n- [以SVG的样式展示正则的规则](https://regexper.com/)\n- [比较实用的正则检测网站](https://regex101.com/)","tags":["Regex"]},{"title":"CentOs 安装 MySql","url":"/blog/2020/04/21/CentOs安装MySql/","content":"\n## 安装环境\n\n系统：CentOS Linux release 8.1.1911 (Core) | MySQL版本：8.0.17 | 博客记录时间：2020-4-21 15:21:36\n\n## 安装MySQL\n\n查看MySQL [官网](https://www.mysql.com/) 提供的 [MySQL Yum Repository](https://dev.mysql.com/downloads/repo/yum/) ，这里我们选择 **Red Hat Enterprise Linux 8 / Oracle Linux 8 (Architecture Independent), RPM Package**\n\n> 根据自己的 Linux 版本挑选 RPM Package 版本，这里演示的环境是 Linux 8\n\n## 检查系统版本\n```shell\n# 查看系统版本\n[unshell@localhost /]$ cat /etc/redhat-release\nCentOS Linux release 8.1.1911 (Core)\n# 选择合适版本的 Yum 源\nmysql80-community-release-el8-1.noarch.rpm\n```\n\n## 开始之前\n\n```shell\n# 直接切换成root账号,避免权限不足造成其他问题\n[unshell@localhost /]$ su root\nPassword: \n[root@localhost /]# \n# 当然你如果不想切换账号,那在需要权限的命令前加上sudo\n[unshell@localhost /]$ sudo [需要权限的命令]\nPassword:\n```\n\n## 安装YUM仓库\n\n```bash\n# 下载到当前目录下\nwget https://repo.mysql.com//mysql80-community-release-el8-1.noarch.rpm\n# 使用 yum 本地安装 【方法一】\nyum localinstall mysql80-community-release-el8-1.noarch.rpm\n# 或者【方法二】\nrpm -ivh mysql80-community-release-el8-1.noarch.rpm\n# 查看包源是否安装成功【方法一】\nyum repolist enabled | grep \"mysql.*-community.*\"\n# 输出内容如下\nmysql-connectors-community           MySQL Connectors Community              42\nmysql-tools-community                MySQL Tools Community                   19\nmysql80-community                    MySQL 8.0 Community Server              31\n# 或者【方法二】\nyum list installed | grep mysql\n# 输出内容如下\nmysql80-community-release.noarch\n```\n\n## 配置MySQL服务\n\n```bash\n# 安装 MySQL 服务【方法一】\nyum install mysql-server\n# 或者【方法二】\nyum install mysql-community-server\n# 启动 MySQL 服务\nsystemctl start mysqld\n# 查看 MySQL 服务状态\nsystemctl status mysqld\n# 输出如下则表示开启\n● mysqld.service - MySQL 8.0 database server\n   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; disabled; vendor preset: disabled)\n   Active: active (running) since Tue 2020-04-21 16:22:47 CST; 10s ago\n  Process: 11914 ExecStartPost=/usr/libexec/mysql-check-upgrade (code=exited, status=0/SUCCESS)\n  Process: 11787 ExecStartPre=/usr/libexec/mysql-prepare-db-dir mysqld.service (code=exited, status=0/SUCCESS)\n  Process: 11763 ExecStartPre=/usr/libexec/mysql-check-socket (code=exited, status=0/SUCCESS)\n Main PID: 11871 (mysqld)\n   Status: \"Server is operational\"\n    Tasks: 39 (limit: 4888)\n   Memory: 328.3M\n   CGroup: /system.slice/mysqld.service\n           └─11871 /usr/libexec/mysqld --basedir=/usr\n```\n\n## 卸载Mysql服务\n```bash\n#找到已安装的 rpm 包名\nrpm -qa | grep mysql\n# 卸载 rpm 包\nrpm -e [包名]\n# 清理缓存\nyum clean all\n```\n\n## 配置MySQL数据库\n\n```mysql\n# 查看MySQL服务日志与password相关的内容\ngrep 'password' /var/log/mysql/mysqld.log\n# 演示时输出如下\n2020-04-21T08:22:41.675426Z 5 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.\n# 这里提示我们Server为root@localhost账号创建了个空的密码,我们这里直接登入MySQL\nmysql -u root -p\nEnter password: \n# 直接回车，输出如下及登入成功\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 8\nServer version: 8.0.17 Source distribution\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n# 修改root@localhost的密码(这里演示修改密码为：qwe123)\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'qwe123';\nQuery OK, 0 rows affected (0.08 sec)\n# 为外网访问添加账户(%代表所有地址都可能访问,使用时根据实际情况)\nCREATE USER 'unshell'@'%' IDENTIFIED BY 'qwe123';\n# 授予权限(这里演示提供所有权限,使用时根据实际情况)\nGRANT ALL ON *.* TO 'unshell'@'%' WITH GRANT OPTION;\n```\n\n## 开启防火墙对应端口\n\n```bash\n# 开放默认3306端口\nfirewall-cmd --add-port=3306/tcp --permanent\n# 输出success说明成功\nsuccess\n# 更新防火墙规则\nfirewall-cmd --reload\n# 查看防火墙状况\nfirewall-cmd --list-all\n# 输出内容如下说明成功添加3306端口\npublic (active)\n  target: default\n  icmp-block-inversion: no\n  interfaces: ens160\n  services: cockpit dhcpv6-client ssh\n  ports: 3306/tcp \n# 如果未成功，可以尝试重启防火墙\nfirewall-cmd --complete-reload\n```\n\n## 卸载MySQL\n\n```bash\n# 关闭MySQL服务\nsystemctl stop mysqld\n# 查找已安装的MySQl相关的包\nrpm -qa|grep -i mysql\n# 移除输出的包\nyum remove [package]\n# 查询相关的文件夹\nfind / -name mysql\n# 删除输出的文件夹\nrm -rf [directory]\n# 有需要的话也可以3306端口\nfirewall-cmd --permanent --remove-port=3306/tcp\n```\n\n## 相关文档\n\n- [Installing MySQL on Linux Using the MySQL Yum Repository](https://dev.mysql.com/doc/refman/8.0/en/linux-installation-yum-repo.html)","tags":["Mysql"]},{"title":"Windows 安装 Mysql","url":"/blog/2020/03/03/Windows安装Mysql/","content":"\n## 环境\n\n操作系统：Windows 10 | MySQL 版本 8.0.16 | 博客记录时间：2020/3/1 16:05\n\n## 安装 MySQL Community Server\n\n进入 MySQL官网 [下载最新版](https://dev.mysql.com/downloads/mysql/) 或 [其他版本](https://downloads.mysql.com/archives/community/) ZIP Archive：\n\n![fast-use-mysql01](/blog/image/mysql/fast-use-mysql01.png)\n\n> 当前最高版本是8.0.19，我们这里拿8.0.16做演示，目前来说8系列安装都差不多\n\n点击下载后进入到下个页面，选择 No thanks, just start my download：\n\n![fast-use-mysql02](/blog/image/mysql/fast-use-mysql02.png)\n\n下载完之后进行解压，这里我们把压缩包解压在 F:\\mysql\n\n以 **管理员的身份** 打开 cmd 命令行工具，切换目录并输入 mysql 如下：\n\n```shell\ncd F:\\mysql\\bin\nmysql\n// 如果输出如下，就可以开始装载服务了\nERROR 2003 (HY000): Can't connect to MySQL server on 'localhost' (10061)\n```\n\n> 如果你的系统特别干净，可能会跳出提示框提示你缺少dll文件，只要把 [msvcp140.dll](/blog/image/mysql/msvcp140.dll) 和 [vcruntime140.dll](/blog/image/mysql/vcruntime140.dll) 放在 系统盘的Windows\\System32 文件夹下再输入 mysql 就可以了。\n\n## 配置 MySQL 服务\n\n在配置 MySQL 服务之前，我们先配置下 MySQL 的配置文件，创建名为 **my.ini** 的文件在 F:\\mysql\\ 目录下，配置内容如下：\n\n```ini\n[client]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8mb4\n\n[mysqld]\n# 设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir=F:\\\\mysql\n# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错\n# datadir=F:\\\\sqldata\n# 允许最大连接数\nmax_connections=100\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8mb4\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n```\n\n之后我们再使用 cmd 命令行工具初始化数据库：\n\n```shell\nmysqld --initialize --console\n```\n\n- --initialize : 初始化\n- --console : 输出在控制台\n\n执行完成后，会输出 root 用户的初始化密码，如下：\n\n```shell\n....\n[Note] [MY-010454] [Server] A temporary password is generated for root@localhost: g)tqN+Oia4_a\n....\n```\n\n**g)tqN+Oia4_a** 就是初始化密码，之后登入会用到：\n\n输入以下安装命令：\n\n```shell\nmysqld install\n```\n\n之后启动服务：\n\n```shell\nnet start mysql\n```\n\n## 登入MySQL\n\n```shell\nmysql -h 主机名 -u 用户名 -p\n```\n\n参数说明：\n\n- -h：指定客户端要登录的 MySQL 主机名，登录本机（localhost 或 127.0.0.1）该参数可以省略；\n- -u：登录的用户名；\n- -p：告诉服务器将会使用一个密码来登录，如果所要登录的用户名密码为空, 可以忽略此选项。\n\n登入实例如下：\n\n```shell\nmysql -u root -p\n```\n\n按 Enter 键后确认，如果MySQL正在运行则会得到如下响应：\n\n```shell\nEnter password:\n```\n\n输入刚才的密码：**g)tqN+Oia4_a**\n\n```shell\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 9\nServer version: 8.0.16 MySQL Community Server - GPL\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\nmysql>\n```\n\n如果输出为以上的内容说明已经可以登录 MySQL 了。\n\n## 修改密码\n\n值得一提的是MySQL 8和低版本的MySQL修改密码的方式有差别，而且密码的编码方式也有区别\n\n```mysql\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'qwe123';\nQuery OK, 0 rows affected (0.34 sec)\n```\n\n如果你使用数据库连接工具，如 **Navicat Premium** 连接的时候可能在当前版本得修改密码编码方式，否者会提示：\n\n> [ERROR 2059] - Authentication plugin 'caching_sha2_password' cannot be loaded...\n\n修改密码编码方式如下：\n\n```mysql\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'qwe123';\nQuery OK, 0 rows affected (0.12 sec)\nmysql> FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.04 sec)\nmysql> SELECT HOST,USER,PLUGIN FROM MYSQL.USER;\n+-----------+------------------+-----------------------+\n| HOST      | USER             | PLUGIN                |\n+-----------+------------------+-----------------------+\n| localhost | mysql.infoschema | caching_sha2_password |\n| localhost | mysql.session    | caching_sha2_password |\n| localhost | mysql.sys        | caching_sha2_password |\n| localhost | root             | mysql_native_password |\n+-----------+------------------+-----------------------+\n4 rows in set (0.00 sec)\n```\n\n可以看到用户为 root 的 PLUGIN 已经改成了 mysql_native_password。\n\n到这里就一切准备就绪了！\n\n## 删除 MySQL Community Server\n\n## 停止服务\n\n使用管理员身份打开 CMD ，输入net stop mysql：\n\n```shell\nnet stop mysql\nMySQL 服务正在停止...\nMySQL 服务已成功停止。\n// 如果不是管理员身份可能发生下面的情况\n发生系统错误 5。\n拒接访问。\n```\n\n## 删除 Windows 注册表\n\n```shell\nsc delete mysql\n[SC] DeleteService 成功\n```\n\n## 删除环境变量\n\n如果之前有配置环境变量的话，将Path里关于MySQL的环境变量删除即可\n\n## 相关文档\n\n- [MySQL 安装 | 菜鸟教程](https://www.runoob.com/mysql/mysql-install.html)\n- [Installing MySQL on Microsoft Windows](https://dev.mysql.com/doc/refman/8.0/en/windows-installation.html)","tags":["Windows"]}]